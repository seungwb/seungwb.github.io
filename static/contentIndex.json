{"index":{"slug":"index","filePath":"index.md","title":"index","links":["프로젝트-별-Issue/프로젝트-별-Issue","개인-프로젝트/개인-프로젝트","공부-정리/공부-정리"],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용프로젝트 별 Issue프로젝트 별 이슈  정리하고 해결까지의 과정을 담은 노트개인 프로젝트프로젝트 구조를 담은 노트공부 정리공부 정리 노트"},"개인-프로젝트/개인-프로젝트":{"slug":"개인-프로젝트/개인-프로젝트","filePath":"개인 프로젝트/개인 프로젝트.md","title":"개인 프로젝트","links":["개인-프로젝트/투두등장/투두등장"],"tags":["root"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용투두등장일정 관리 및 할일 목록을 관리하는 웹 어플리케이션"},"개인-프로젝트/투두등장/REST-API-명세서":{"slug":"개인-프로젝트/투두등장/REST-API-명세서","filePath":"개인 프로젝트/투두등장/REST API 명세서.md","title":"REST API 명세서","links":[],"tags":["PJTTODO"],"content":"AUTH\n로그인\nURL\n\nPOST : /api/auth/sign-in\n\nHeader\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionemailstring/ String이메일passwordstring/ String패스워드\nResponse\nSuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지tokenstring/ StringJWTexpirationTimenumber/ intJWT 만료 시간\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;token&quot;: &quot;vlfdskjhfiweauhklsjdcflkdjshaiweliru&quot;,\n\t&quot;expirationTime&quot;: 3600\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttp status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n회원 가입\nURL\n\nPOST : /api/auth/sign-up\n\nHeader\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionemailstring/ String이메일passwordstring/ String비밀번호namestring/ String이름phonestring/ String전화번호\nResponse\nSuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;token&quot;: &quot;vlfdskjhfiweauhklsjdcflkdjshaiweliru&quot;,\n\t&quot;expirationTime&quot;: 3600\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;DE&quot;,\n\t&quot;message&quot;: &quot;Duplicate email.&quot;\n}\n\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;DP&quot;,\n\t&quot;message&quot;: &quot;Duplicate Phone.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\nIndex\n오늘의 날씨\nURL\n\nGET : api.openweathermap.org/data/2.5/weather${WHETHER_API_KEY}&amp;units=metric&amp;lang=kr\n\nHeader\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncoordCoord*좌표 정보weatherWeather[]*날씨 상태 정보mainMain*기온 및 기압 정보visibilitynumber/ Integer가시거리 (미터)windWind*바람정보rainRain강수량 정보cloudsClouds*구름 정보dtnumber/ Long*데이터 업데이트 시간sysSys*국가 및 일출/ 일몰 정보timezonenumber/ Integer*타입존idnumber/ Long*도시 IDnamestring/ String*도시 이름codnumber/ Integer*HTTP 응답 코드\nCoord\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionlonnumber/ Double*경도latnumber/ Double*위도\nWeather[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionidnumber/ Integer*날씨 코드mainstring/ String*날씨 상태descriptionstring/ String*상세 설명iconstring/ String*아이콘 코드\nMain\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontempnumber/ Double*현재 기온 (°C)feels_likenumber/ Double*체감 온도 (°C)temp_minnumber/ Double*최저 기온 (°C)temp_maxnumber/ Double*최고 기온 (°C)pressurenumber/ Integer*기압 (hPa)humiditynumber/ Integer*습도 (%)sea_levelnumber/ Integer해수면 기압 (hPa)grnd_levelnumber/ Integer지면 기압 (hPa)\nWind\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionspeednumber/ Double*풍속 (m/s)degnumber/ Integer*풍향 (도)\nRain\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescription1hnumber/ Double최근 1시간 강수량 (mm)\nClouds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionallnumber/ Integer*구름량 (%)\nSys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontypenumber/ Integer시스템 유형idnumber/ Integer시스템 IDcountrystring/ String*국가 코드sunrisenumber/ Long*일출 시간 (UTC)sunsetnumber/ Long*일몰 시간 (UTC)\n{\n\n    &quot;coord&quot;: {\n\n        &quot;lon&quot;: 126.9778,\n\n        &quot;lat&quot;: 37.5683\n\n    },\n\n    &quot;weather&quot;: [\n\n        {\n\n            &quot;id&quot;: 501,\n\n            &quot;main&quot;: &quot;Rain&quot;,\n\n            &quot;description&quot;: &quot;보통 비&quot;,\n\n            &quot;icon&quot;: &quot;10d&quot;\n\n        }\n\n    ],\n\n    &quot;base&quot;: &quot;stations&quot;,\n\n    &quot;main&quot;: {\n\n        &quot;temp&quot;: 11.76,\n\n        &quot;feels_like&quot;: 10.4,\n\n        &quot;temp_min&quot;: 11.76,\n\n        &quot;temp_max&quot;: 12.78,\n\n        &quot;pressure&quot;: 1016,\n\n        &quot;humidity&quot;: 54,\n\n        &quot;sea_level&quot;: 1016,\n\n        &quot;grnd_level&quot;: 1006\n\n    },\n\n    &quot;visibility&quot;: 8000,\n\n    &quot;wind&quot;: {\n\n        &quot;speed&quot;: 2.06,\n\n        &quot;deg&quot;: 200\n\n    },\n\n    &quot;rain&quot;: {\n\n        &quot;1h&quot;: 1.78\n\n    },\n\n    &quot;clouds&quot;: {\n\n        &quot;all&quot;: 75\n\n    },\n\n    &quot;dt&quot;: 1740808198,\n\n    &quot;sys&quot;: {\n\n        &quot;type&quot;: 1,\n\n        &quot;id&quot;: 8105,\n\n        &quot;country&quot;: &quot;KR&quot;,\n\n        &quot;sunrise&quot;: 1740780248,\n\n        &quot;sunset&quot;: 1740821111\n\n    },\n\n    &quot;timezone&quot;: 32400,\n\n    &quot;id&quot;: 1835848,\n\n    &quot;name&quot;: &quot;Seoul&quot;,\n\n    &quot;cod&quot;: 200\n\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodstring/ String코드messagestring/ String메시지\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;cod&quot;: 401,\n\n    &quot;message&quot;: &quot;Invalid API key. Please see openweathermap.org/faq#error401 for more info.&quot;\n}\n\n오늘의 일정\nURL\n\nGET : /api/schedule/today?today={today}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지todayScheduleListItemsScheduleListItems[]*오늘의 일정 리스트 아이템\nCalendarListItem[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionidnumber/ Long*글 번호namestring/ String*작성자titlestring/ String*제목contentstring/ String내용startDateDate/ OffesetDateTime*일정 시작 시간endDateDate/ OffesetDateTime*일정 마감 시간regDateDate/ OffesetDateTime*일정 작성 일자locationstring/ String장소\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;scheduleListItems&quot;:[\n\t\t{\n\t\t\t&quot;id&quot;: 1,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;코딩 공부&quot;,\n\t\t\t&quot;content&quot;: &quot;코딩테스트 하기&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-12 12:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-12 15:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-11 05:00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;집&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;id&quot;: 2,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;친구와 약속&quot;,\n\t\t\t&quot;content&quot;: &quot;놀기&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-12 16:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-12 19:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-11 :00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;집&quot;\n\t\t}\n\t]\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\nTodo 리스트\nURL\n\nGET : /api/todo\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n이번주 일정\nURL\n\nGET : /api/schedule/weekly?start={start}&amp;end={end}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지weeklyScheduleListItemsScheduleListItems[]*이번주 일정 리스트 아이템\nCalendarListItem[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionidnumber/ Long*글 번호namestring/ String*작성자titlestring/ String*제목contentstring/ String내용startDateDate/ OffesetDateTime*일정 시작 시간endDateDate/ OffesetDateTime*일정 마감 시간regDateDate/ OffesetDateTime*일정 작성 일자locationstring/ String장소\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;scheduleListItems&quot;:[\n\t\t{\n\t\t\t&quot;id&quot;: 1,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;코딩 공부&quot;,\n\t\t\t&quot;content&quot;: &quot;코딩테스트 하기&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-12 12:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-12 15:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-11 05:00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;집&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;id&quot;: 2,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;친구와 약속&quot;,\n\t\t\t&quot;content&quot;: &quot;놀기&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-12 16:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-12 19:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-11 :00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;집&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;id&quot;: 3,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;결혼식&quot;,\n\t\t\t&quot;content&quot;: &quot;&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-14 16:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-14 19:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-01 :00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;서울울&quot;\n\t\t}\n\t]\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\nSchedule\n일정 리스트 조회\nURL\n\nGET : /api/schedule\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지scheduleListItemsScheduleListItems[]*일정 리스트 아이템\nCalendarListItem[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionidnumber/ Long*글 번호namestring/ String*작성자titlestring/ String*제목contentstring/ String내용startDateDate/ OffesetDateTime*일정 시작 시간endDateDate/ OffesetDateTime*일정 마감 시간regDateDate/ OffesetDateTime*일정 작성 일자locationstring/ String장소\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;scheduleListItems&quot;:[\n\t\t{\n\t\t\t&quot;id&quot;: 1,\n\t\t\t&quot;name&quot;: &quot;백철수&quot;,\n\t\t\t&quot;title&quot;: &quot;코딩 공부&quot;,\n\t\t\t&quot;content&quot;: &quot;코딩테스트 하기&quot;,\n\t\t\t&quot;startDate&quot;: &quot;2025-02-12 12:00:00&quot;,\n\t\t\t&quot;endDate&quot;: &quot;2025-02-12 15:00:00&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-11 05:00:00&quot;,\n\t\t\t&quot;lacation&quot;: &quot;집&quot;\n\t\t}\n\t]\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n일정 리스트 저장\nURL\n\nPOST : /api/schedule\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontitlestring/ String*제목contentstring/ String내용locationstring/ String장소startDateDate/ OffsetDateTime*시작 시간endDateDate/ OffsetDateTime*마감 시간\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n일정 리스트 수정\nURL\n\nPUT : /api/schedule/{id}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontitlestring/ String*제목contentstring/ String내용locationstring/ String장소startDateDate/ OffsetDateTime*시작 시간endDateDate/ OffsetDateTime*마감 시간\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NS&quot;,\n\t&quot;message&quot;: &quot;This Schedule does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n일정 리스트 삭제\nURL\n\nDELETE : /api/schedule/{id}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NS&quot;,\n\t&quot;message&quot;: &quot;This Schedule does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n할일 목록\n할일 조회\nURL\n\nGET : /api/todo\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지todoListItemsTodoListItems[]*할일 리스트\nTodoListItems[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionidnumber/ Long*할일 번호titlestring/ String*제목contentstring/ String내용regDateDate/ OffesetDateTime*할일 작성 일자stateboolean/ Boolean*상태memberIdnumber/ Long*작성자 ID\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;,\n\t&quot;todoListItems&quot;:[\n\t\t{\n\t\t\t&quot;id&quot;: 1,\n\t\t\t&quot;title&quot;: &quot;청소하기&quot;,\n\t\t\t&quot;content&quot;: &quot;내방&quot;,\n\t\t\t&quot;regDate&quot;: &quot;2025-02-27 12:00:00&quot;,\n\t\t\t&quot;state&quot;: true,\n\t\t\t&quot;memberId&quot;: 1\n\t\t}\n\t]\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n할일 저장\nURL\n\nPOST : /api/todo\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontitlestring/ String*제목contentstring/ String내용\n{\n\t&quot;title&quot;: &quot;청소하기&quot;,\n\t&quot;content&quot;: &quot;내방&quot;\n}\n\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n할일 수정\nURL\n\nPUT : /api/todo/{id}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptiontitlestring/ String*제목contentstring/ String내용\n{\n\t&quot;title&quot;: &quot;청소하기&quot;,\n\t&quot;content&quot;: &quot;내방&quot;\n}\n\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NT&quot;,\n\t&quot;message&quot;: &quot;This Todo does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n할일 상태 수정\nURL\n\nPUT : /api/todo/toggle/{id}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptionstateboolean/ Boolean*상태\n{\n\t&quot;state&quot;: false\n}\n\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NT&quot;,\n\t&quot;message&quot;: &quot;This Todo does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n\n할일 삭제\nURL\n\nDELETE : /api/todo/{id}\n\nHeader\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueAuthorizationBearer Token\nRequest\nResponse\nsuccess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String*코드messagestring/ String*메시지\nHttps Status - 200 (OK)\n\n{\n\t&quot;code&quot;: &quot;SU&quot;,\n\t&quot;message&quot;: &quot;Success&quot;\n}\n\nFail\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameType (front/ back)RequiredDescriptioncodestring/ String코드messagestring/ String메시지\nHttps status - 400 (Bad Request)\n\n{\n\t&quot;code&quot;: &quot;VF&quot;,\n\t&quot;message&quot;: &quot;Validation Failed&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NU&quot;,\n\t&quot;message&quot;: &quot;This user does not exist.&quot;\n}\n\nHttps status - 401 (Unauthorized)\n\n{\n\t&quot;code&quot;: &quot;NT&quot;,\n\t&quot;message&quot;: &quot;This Todo does not exist.&quot;\n}\n\nHttps status - 500 (Internal Server Error)\n\n{\n\t&quot;code&quot;: &quot;DBE&quot;,\n\t&quot;message&quot;: &quot;Database error&quot;\n}\n"},"개인-프로젝트/투두등장/기획":{"slug":"개인-프로젝트/투두등장/기획","filePath":"개인 프로젝트/투두등장/기획.md","title":"기획","links":[],"tags":["PJTTODO"],"content":"페이지별 기능\nMember\n\n\nIndex page\n\n필수 기능\n\n 오늘의 날씨 조회\n 오늘의 일정 조회\n 할일 목록 조회\n 이번주 일정 조회\n\n\n추가 기능\n\n\n\nSchedule page\n\n필수 기능\n\n 캘린더 뷰 (FullCalendar 라이브러리)\n 일정 CRUD\n\n\n추가 기능\n\n 알림 기능\n 다크 모드\n 이전 일정, 오늘 일정, 차후 일정 나눠서 볼 수 있도록\n\n\n\n\n\nAuth page\n\n\nSignin\n\n필수 기능\n\n 일반 로그인 기능\n\n\n추가 기능\n\n 소셜 로그인 기능 (구글, 네이버)\n 아이디 저장\n  비밀번호 직접 보일수도 있도록 구현\n\n\n\n\n\nSignup\n\n필수 기능\n\n  이름 - 한글만 들어가도록 유효성 검사, 2글자 이상50\n  이메일 - 유효성 검사\n  비밀번호 - 한글이 들어가지 않도록 유효성 검사, 7자 이상\n  비밀번호 확인 - 비밀번호랑 일치하는지 확인\n\n\n추가 기능\n\n Google Mail 이용하여 메일 확인 기능\n\n\n\n\n\n\n\nTodo page\n\n필수 기능\n\n  할일 CRUD 기능\n  할일 상태를 바로 수정 가능하도록 구현\n\n\n추가 기능\n\n 다크 모드\n\n\n\n\n"},"개인-프로젝트/투두등장/아키텍처-설계":{"slug":"개인-프로젝트/투두등장/아키텍처-설계","filePath":"개인 프로젝트/투두등장/아키텍처 설계.md","title":"아키텍처 설계","links":["개인-프로젝트/투두등장/REST-API-명세서"],"tags":["PJTTODO"],"content":"시스템 개요\n\n프로젝트 명: 투두등장\n프로젝트 목적: 일정을 관리하기위한 웹 애플리케이션 개발\n기술 스택\n\n백엔드\n\n사용 기술     \n패키지 관리\n개발 환경   \n배포   \n\n\n프론트엔드\n\n사용 기술           \n설정 및 패키지 관리  \n개발 환경   \n배포  \n\n\n\n\n\n아키텍처 다이어그램\n\n프론트엔드: React + Vite + Tailwind CSS\n백엔드: Spring Boot + JPA + Spring Security\n데이터 베이스: PostgreSQL\nAPI 연동: RESTful API ( JWT 인증 사용 )\n외부 서비스: OpenWeather API, FullCalendar 라이브러리\n배포 환경: Render ( 백엔드 ), Vercel ( 프론트엔드 ) + GitHub Actions\n\n\n주요 기능\n프론트엔드\n\n날씨 정보 제공 (OpenWeatherMap API 연동)\n일정 관리 (Fullcalendar 기반 일정 추가, 수정, 삭제)\n할 일 관리 (To-Do 리스트 추가, 수정, 삭제, 완료 체크로 할일 완료 여부 관리)\n반응형 UI 지원\n\n백엔드\n\n일정 관리 API (CRUD)\n할 일 관리 API (CRUD)\nJWT 기반 사용자 인증\n예외 처리 및 보안 필터 적용\n\n데이터베이스 설계\nERD\n\n테이블\nMember\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키컬럼명자료형컬럼타입기본값비고PKIDLongBIGINT(20)auto_incrementNAMEStringVARCHAR(255)EMAILStringVARCHAR(255)PHONEStringVARCHAR(255)PASSWORDStringVARCHAR(255)JOIN_DATEOffsetDateTimeTIMESTAMPcurrent_timestamp\nMember_Role\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키컬럼명자료형컬럼타입기본값비고PKIDLongBIGINT(20)auto_incrementROLE_NAMEStringVARCHAR(255)FKMEMBER_IDLongBIGINT(20)\nSchedule\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키컬럼명자료형컬럼타입기본값비고PKIDLongBIGINT(20)auto_incrementTITLEStringVARCHAR(255)CONTENTStringVARCHAR(2000)START_TIMEOffsetDateTimeTIMESTAMPEND_TIMEOffsetDateTimeTIMESTAMPLOCATIONStringVARCHAR(255)REG_DATEOffsetDateTimeTIMESTAMPcurrent_timestampFKMEMBER_IDLongBIGINT(20)\nTodo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키컬럼명자료형컬럼타입기본값비고PKIDLongBIGINT(20)auto_incrementTITLEStringVARCHAR(255)CONTENTStringVARCHAR(2000)REG_DATEOffsetDateTimeTIMESTAMPcurrent_timestampFKMEMBER_IDLongBIGINT(20)\nAPI 설계\nREST API 설계\nHTTP 코드\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP 상태 코드상태지정할 코드명표시할 메시지200성공”SU&quot;&quot;Success.”400유효성 검증 실패”VF&quot;&quot;Validation failed.”중복된 이메일”DE&quot;&quot;Duplicate email.”중복된 전화번호”DP&quot;&quot;Duplicate Phone.”존재하지 않는 유저”NU&quot;&quot;This user does not exist.”존재하지 않는 일정”NS&quot;&quot;This Schedule does not exist.”존재하지 않는 할일”NT&quot;&quot;This Todo does not exist.”401로그인 실패”SF&quot;&quot;Login information mismatch.”500데이터베이스 에러”DBE&quot;&quot;Database error.”\nData Flow\n사용자 인증\n\n사용자 회원가입 → Spring Security로 비밀번호 암호화 후 저장\n로그인 시 JWT 토큰 발급 → 프론트에서 저장 후 API 요청 시 헤더에 포함\n\n일정/ 할 일 관리\n\n사용자가 일정 혹은 할 일 추가 요청 → 백엔드 API → PostgreSQL 에 저장 → 성공 실패 판별 후 관련 응답 코드 프론트로 전송\n사용자가 일정 혹은 할 일 수정 요청 → 백엔드 API → PostgreSQL 에 수정 → 성공 실패 판별 후 관련 응답 코드 프론트로 전송\n사용자가 일정 혹은 할 일 조회 요청 → 백엔드 API → PostgreSQL 에서 조회 → 성공 시 조회 한 목록 + 성공 응답 코드 발송/ 실패 시 실패 응답 코드 발송\n사용자가 일정 혹은 할 일 삭제 요청 → 백엔드 API → PostgreSQL 에서 삭제 → 성공 실패 판별 후 관련 응답 코드 프론트로 전송\n\n날씨 데이터\n\n프론트에서 OpenWeather API 요청 → 응답 데이터를 받아 데이터 가공 후 화면에 표시\n"},"개인-프로젝트/투두등장/투두등장":{"slug":"개인-프로젝트/투두등장/투두등장","filePath":"개인 프로젝트/투두등장/투두등장.md","title":"투두등장","links":["개인-프로젝트/투두등장/REST-API-명세서","개인-프로젝트/투두등장/아키텍처-설계","개인-프로젝트/투두등장/기획"],"tags":["PJT"],"content":"\nREST API 명세서\n아키텍처 설계\n기획\n"},"공부-정리/Git/Git":{"slug":"공부-정리/Git/Git","filePath":"공부 정리/Git/Git.md","title":"Git","links":[],"tags":["ETCStudy"],"content":"TABLE file.path AS &quot;경로&quot; FROM &quot;공부 정리/Git&quot; WHERE file.name != &quot;Git&quot; SORT file.name asc"},"공부-정리/JSP/JSP":{"slug":"공부-정리/JSP/JSP","filePath":"공부 정리/JSP/JSP.md","title":"JSP","links":[],"tags":["ETCStudy"],"content":"const currentFile = dv.current();\nconst currentFilePath = currentFile.file.path;\nconst currentFolder = currentFile.file.folder;\nconst currentFolderName = currentFolder.split(&#039;/&#039;).pop();\n \nconst isWebExport = typeof app === &quot;undefined&quot;;\n \nconst files = dv.pages(`&quot;${currentFolder}&quot;`)\n  .where(p =&gt; p.file.name != currentFolderName)\n  .sort(p =&gt; p.file.name);\n \nlet html = &#039;&lt;table class=&quot;dataview table-view-table&quot;&gt;&#039;;\nhtml += &#039;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;목차&lt;/th&gt;&lt;th&gt;경로&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&#039;;\nhtml += &#039;&lt;tbody&gt;&#039;;\n \nfiles.forEach((page, index) =&gt; {\n  const fileName = page.file.name;\n  const filePath = page.file.path;\n \n  // HTML 링크 대신 span으로 감싸고 클릭 이벤트 사용\n  html += &#039;&lt;tr&gt;&#039;;\n  html += `&lt;td&gt;&lt;span class=&quot;file-link&quot; data-path=&quot;${filePath}&quot; style=&quot;color: var(--link-color); text-decoration: underline; cursor: pointer;&quot;&gt;${fileName}&lt;/span&gt;&lt;/td&gt;`;\n  html += `&lt;td&gt;${filePath}&lt;/td&gt;`;\n  html += &#039;&lt;/tr&gt;&#039;;\n});\n \nhtml += &#039;&lt;/tbody&gt;&lt;/table&gt;&#039;;\n \ndv.paragraph(html);\n \n// Obsidian에서 링크 클릭 시 해당 노트 열기\nif (!isWebExport) {\n  const links = this.container.querySelectorAll(&quot;.file-link&quot;);\n  links.forEach(link =&gt; {\n    link.addEventListener(&quot;click&quot;, (e) =&gt; {\n      const path = e.target.getAttribute(&quot;data-path&quot;);\n      app.workspace.openLinkText(path, &quot;&quot;, false);\n    });\n  });\n}"},"공부-정리/공부-정리":{"slug":"공부-정리/공부-정리","filePath":"공부 정리/공부 정리.md","title":"공부 정리","links":["공부-정리/자바-기초/자바-기초","공부-정리/자바-중급/자바-중급","공부-정리/스프링-입문/스프링-입문","공부-정리/스프링-핵심-원리---기본편/스프링-핵심-원리---기본편","공부-정리/네트워크/네트워크","공부-정리/Git/Git","공부-정리/JSP/JSP","공부-정리/투두등장/투두등장"],"tags":["root"],"content":"강의 중 공부 정리\nJava\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용자바 기초인프런 이영한 강사님 수업자바 중급인프런 이영한 강사님 수업\nSpring\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용스프링 입문인프런 이영한 강사님 수업스프링 핵심 원리 - 기본편인프런 이영한 강사님 수업\n기타\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용네트워크인프런 이영한 강사님 수업Git-JSP-\n프로젝트 중 공부 정리\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용투두등장프로젝트 중 공부한 것들 정리한 노트"},"공부-정리/네트워크/HTTP-기본":{"slug":"공부-정리/네트워크/HTTP-기본","filePath":"공부 정리/네트워크/HTTP 기본.md","title":"HTTP 기본","links":[],"tags":[],"content":""},"공부-정리/네트워크/HTTP-메서드":{"slug":"공부-정리/네트워크/HTTP-메서드","filePath":"공부 정리/네트워크/HTTP 메서드.md","title":"HTTP 메서드","links":[],"tags":[],"content":""},"공부-정리/네트워크/URI와-웹-브라우저-요청-흐름":{"slug":"공부-정리/네트워크/URI와-웹-브라우저-요청-흐름","filePath":"공부 정리/네트워크/URI와 웹 브라우저 요청 흐름.md","title":"URI와 웹 브라우저 요청 흐름","links":[],"tags":[],"content":""},"공부-정리/네트워크/네트워크":{"slug":"공부-정리/네트워크/네트워크","filePath":"공부 정리/네트워크/네트워크.md","title":"네트워크","links":["공부-정리/네트워크/인터넷-네트워크"],"tags":["ETCStudy"],"content":"\n인터넷 네트워크\n"},"공부-정리/네트워크/인터넷-네트워크":{"slug":"공부-정리/네트워크/인터넷-네트워크","filePath":"공부 정리/네트워크/인터넷 네트워크.md","title":"인터넷 네트워크","links":[],"tags":["NetworkStudy"],"content":"IP (Internet Protocol)\n정의\n\nOSI 참조 모델의 3계층인 네트워크 계층에서 사용되는 네트워크 프로토콜\n\n역할\n\n네트워크상의 기기에 주소를 할당\n지정한 IP 주소에 데이터 전달\n패킷이라는 통신 단위로 데이터 전달\n\n한계\n\n비연결성\n\n패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송\n\n\n비신뢰성\n\n중간에 패킷이 사라지는 경우가 있을 수 있다.\n패킷이 순서대로 오지않을 수 있다.\n\n\n프로그램 구분\n\n같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 때 구분할 수 있는 방법이 없다.\n\n\n\nTCP (Transmission Control Protocol)\n특징\n\n연결지향 - TCP 3 way handshake (가상 연결)\n데이터 전달 보증\n순서 보장\n\nTCP 3 way handshake\n\n신뢰성 있는 연결을 성정하기 위해 클라이언트와 서버간에 이루어지는 초기 과정\n이 과정을 통해 클라이언트와 서버가 서로 데이터 전송을 할 수 있는 상태가 되어 있음을 확인\n\n\nUDP (User Datagram Protocol)\n\nTCP와 반대적인 성향을 가지고 있다\n\n특징\n\n연결지향적이지 않다.\n데이터 전달 여부가 보증되지 않는다.\n순서가 보장되지 않는다.\n데이터 전달 여부가 보장되지 않고 순서가 보장되지 않는 만큼, 단순하여 데이터 전달 속도가 빠르다.\n"},"공부-정리/스프링-입문/01.-프로젝트-환경-설정":{"slug":"공부-정리/스프링-입문/01.-프로젝트-환경-설정","filePath":"공부 정리/스프링 입문/01. 프로젝트 환경 설정.md","title":"01. 프로젝트 환경 설정","links":[],"tags":["SpringBasis"],"content":"프로젝트 생성\n\nstart.spring.io 사이트에서 스프링 프로젝트 생성\n\n\n\nProject: 프로젝트 종류 (Maven, Gradle) 선택\n\nMaven: 빌드 자동화 및 의존성 관리를 위한 도구. XML 기반(pom.xml) 설정 사용. 가장 많이 사용됨.\nGradle: 성능이 더 빠르고 유연한 빌드 시스템. Groovy 또는 Kotlin DSL 기반(build.gradle) 설정 사용.\n\n\nLanguage : 언어 (Java, Kotlin, Groovy) 선택\n\nJava: 가장 널리 사용되는 Spring Boot의 기본 언어.\nKotlin: 간결하고 안전한 코드를 작성할 수 있는 JVM 언어. 최근 사용이 증가.\nGroovy: 동적 언어로, 빠른 개발에 적합하지만 Spring Boot에서 잘 사용되진 않음\n\n\nSpring Boot: 스프링 버전 선택\nProject Metadata\n\nGroup: com.example처럼 패키지 명을 정의 (예: com.myapp)\nArtifact: 프로젝트의 이름 (예: todo-app)\nName: 기본 프로젝트 이름\nDescription: 프로젝트 설명\nPackage Name: Group + Artifact로 자동 생성됨\nPackaging:\n\nJar (기본값): 독립 실행형 애플리케이션을 만들 때 사용.\nWar: Tomcat 같은 웹 서버에 배포할 때 사용.\n\n\nJava: Java 버전 선택\n\n\nDependencies: Spring Boot 애플리케이션에 필요한 라이브러리(모듈)를 추가할 수 있음.\n\n간단한 작동 원리\n\n\n웹 브라우저에서 localhost:8080/hello 를 요청하면 응답을 받은 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버(viewResolver)가 화면을 찾아서 처리한다.\n\nresources:templates/+{ViewName}+.html\n\n\n\nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.GetMapping;  \n  \n  \n@Controller  \npublic class HelloController {  \n  \n    @GetMapping(&quot;hello&quot;)        // /hello 응답 받음  \n    public String hello(  \n    Model model){             \n\t\t//model의 &quot;data&quot;라는 이름에 &quot;spring!!&quot;을 동적으로 넣는다.  \n        model.addAttribute(&quot;data&quot;,&quot;spring!!&quot;);  \n  \n        return &quot;hello&quot;;     //리턴을 resources/templates에 있는 hello.html로 이동  \n    }  \n}\n&lt;!DOCTYPE HTML&gt;  \n&lt;html xmlns:th=&quot;www.thymeleaf.org&quot;&gt;  \n\t&lt;head&gt;  \n\t    &lt;title&gt;Hello&lt;/title&gt;  \n\t    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;  \n\t&lt;/head&gt;  \n\t&lt;body&gt;  \n\t\t&lt;p th:text=&quot;&#039;안녕하세요. &#039; + ${data}&quot; &gt;안녕하세요. 손님&lt;/p&gt;  \n\t&lt;/body&gt;  \n&lt;/html&gt;\n빌드하고 실행하기\n\n콘솔에서 프로젝트 경로로 이동한후 아래와 같이 작동\n\n./gradlew build         #Mac &amp; Linux\n./gradlew.bat build     #Windows\n \ncd build/libs\njava -jar hello-spring-0.0.1-SNAPSHOT.jar\n\n주의사항: 같은 port 에서 하나의 톰캣만 실행가능하므로 IDE에서 실행중이면 실행이 되지 않으니 꼭 IDE에서 작동을 멈춘 후 시도하도록 한다.\n"},"공부-정리/스프링-입문/02.-스프링-웹-개발-기초":{"slug":"공부-정리/스프링-입문/02.-스프링-웹-개발-기초","filePath":"공부 정리/스프링 입문/02. 스프링 웹 개발 기초.md","title":"02. 스프링 웹 개발 기초","links":[],"tags":["SpringBasis"],"content":"정적 컨텐츠\n정적 컨텐츠 이미지\n\n개념\n\nHTML, CSS, JavaScript 같은 변하지 않는 파일을 그대로 제공하는 방식이다\n클라이언트(브라우저)가 요청하면, 서버는 해당 파일을 그대로 내려준다.\n\n작동 원리\n\n클라이언트가 http://localhost:8080/index.html 요청\nSpring Boot의 static/ 폴더에서 index.html 파일을 찾음\n해당 파일이 존재하면 그대로 브라우저에게 반환\n\n장단점\n\n장점: 서버 부담이 적고 속도가 빠름\n단점: 동적인 데이터 반영 불가\n\nMVC와 템플릿 엔진\n\n개념\n\nSpring MVC 패턴을 사용해 동적인 페이지를 생성하는 방식.\n서버에서 데이터를 가공하여 HTML을 생성한 후, 브라우저에 전달.\n템플릿 엔진(Thymeleaf, JSP, Mustache, FreeMarker 등)을 사용.\n\n작동 원리\n\n사용자가 http://localhost:8080/hello 요청\nSpring MVC의 Controller가 요청을 처리 (@Controller)\n비즈니스 로직에서 데이터를 가져옴 (@Service)\n데이터를 템플릿 엔진(Thymeleaf 등)에 전달하여 HTML 생성\n생성된 HTML을 클라이언트에 반환\n\n장단점\n\n장점: 동적 HTML 페이지 생성 가능, 서버 사이드에서 데이터 가공 후 렌더링\n단점: 매번 HTML을 생성해야 하기 때문에 서버 부담이 큼\n\nAPI\n@ResponseBody 사용 원리\n\n개념\n\n웹 브라우저가 아니라, 프론트엔드(React, Vue, 모바일 앱 등)와 통신할 때 사용.\n데이터를 HTML이 아닌 JSON 형식으로 반환.\nRESTful API 형식으로 클라이언트-서버 간 데이터 교환을 쉽게 함.\n\n작동 원리\n\n사용자가 http://localhost:8080/api/hello 요청\nSpring Boot의 @RestController가 JSON 데이터를 응답\n\n장단점\n\n장점: 프론트엔드(React, Vue 등)와 연동이 쉬움, 속도가 빠르고 가볍다 (HTML 생성 없이 JSON만 전달)\n단점: 클라이언트에서 데이터를 렌더링해야 함 (추가 작업 필요)\n"},"공부-정리/스프링-입문/스프링-입문":{"slug":"공부-정리/스프링-입문/스프링-입문","filePath":"공부 정리/스프링 입문/스프링 입문.md","title":"스프링 입문","links":["공부-정리/스프링-입문/01.-프로젝트-환경-설정","공부-정리/스프링-입문/02.-스프링-웹-개발-기초"],"tags":["SpringStudy"],"content":"\n01. 프로젝트 환경 설정\n02. 스프링 웹 개발 기초\n"},"공부-정리/스프링-핵심-원리---기본편/01.-객체-지향-설계와-스프링":{"slug":"공부-정리/스프링-핵심-원리---기본편/01.-객체-지향-설계와-스프링","filePath":"공부 정리/스프링 핵심 원리 - 기본편/01. 객체 지향 설계와 스프링.md","title":"01. 객체 지향 설계와 스프링","links":["공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍"],"tags":["SpringBasic"],"content":"✅ 스프링(Spring) 이란?\n\n“스프링은 하나의 기술이 아니라, 다양한 기술들의 집합이다.”\nJava 기반의 애플리케이션을 효율적이고 생산적으로 개발할 수 있도록 지원하는 프레임워크 생태계이다.\n\n\n핵심 구성\n🔹 필수(Core)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구성 요소설명스프링 프레임워크(Spring Framework)의존성 주입(DI), AOP, 트랜잭션 관리 등 스프링의 핵심 기능을 제공하는 기반 기술스프링 부트(Spring Boot)복잡한 설정 없이 빠르게 스프링 애플리케이션을 만들 수 있도록 도와주는 편의 도구 (자동 구성, 내장 톰캣 등 포함)\n\n🔹 선택(Optional)\n\n스프링 프레임워크 위에서 사용할 수 있는 모듈들 – 필요에 따라 선택 사용\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n모듈설명Spring DataJPA, MongoDB 등 다양한 DB 연동을 간단하게 처리할 수 있게 도와줌Spring SessionHttpSession을 외부 저장소(Redis 등)에 저장하여 세션 관리 기능을 확장Spring Security인증, 인가 등 보안 관련 기능을 제공하는 강력한 보안 프레임워크Spring RestDocsREST API 문서를 테스트 기반으로 자동 생성해주는 도구Spring Batch대용량 배치 처리(정기 작업, 대규모 데이터 처리)에 특화된 프레임워크Spring Cloud마이크로서비스 아키텍처(MSA)를 클라우드 환경에서 쉽게 구축하고 운영할 수 있도록 지원그 외에도…Spring Integration, Spring WebSocket, Spring AMQP 등 다양한 확장 기술 존재\n✅ 스프링 프레임워크(Spring Framework)\n\n스프링의 핵심 기술들을 담고 있는 기반 프레임워크\n\n🔹 1. 핵심 기술\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명DI 컨테이너객체 간의 의존성을 자동으로 주입하여 코드 간 결합도를 낮춤AOP (Aspect-Oriented Programming)공통 관심사를 모듈화 (예: 로깅, 보안)이벤트애플리케이션 내에서 비동기 이벤트 기반 처리 가능기타다양한 유틸리티 및 API 지원\n\n🔹 2. 웹 기술\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n기술설명Spring MVC전통적인 Servlet 기반 웹 프레임워크Spring WebFlux비동기/논블로킹 방식의 Reactive 웹 프레임워크 (Netty 기반)\n\n🔹 3. 데이터 접근 기술\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n기술설명트랜잭션 관리선언적/프로그래밍 방식의 트랜잭션 처리JDBC, ORMJDBC API, JPA/Hibernate 등 ORM 통합 지원XML 지원설정 파일 등에서 XML 기반 구성 가능\n\n🔹 4. 기술 통합\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n예시설명캐시Caffeine, Redis 등과 연동한 캐시 처리이메일JavaMail 등을 통한 이메일 발송원격접근RMI, HTTP 등을 통한 원격 호출 지원스케줄링정기 작업 실행 (@Scheduled) 등 지원\n\n🔹 5. 테스트 지원\n\nJUnit, Mockito 등과 연계한 테스트 구성 지원\n@SpringBootTest, @ContextConfiguration 등 테스트 유틸 제공\n\n\n🔹 6. 언어 지원\n\nJava 외에도 Kotlin, Groovy 등 지원\n\n\n🔹 7. 최근 경향\n\n스프링 프레임워크의 기능들은 Spring Boot를 통해 더 편리하게 사용할 수 있게 되었으며, 최신 프로젝트에서는 Spring Boot가 사실상 기본으로 자리잡음.\n\n\n✅ 스프링 부트(Spring Boot)\n\n스프링을 쉽게 사용하고 빠르게 배포할 수 있도록 만든 확장 프레임워크\n\n\n🔹 1. 주요 특징\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명빠른 프로젝트 구성복잡한 XML 설정 없이 애플리케이션을 빠르게 시작 가능내장 서버 제공Tomcat, Jetty 등 웹 서버를 내장 → 별도 설치 없이 실행 가능독립 실행형 JAR 생성java -jar 한 줄로 바로 실행 가능\n\n🔹 2. 설정 및 의존성 관리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명Starter 의존성필요한 기능을 묶어둔 패키지 (spring-boot-starter-web 등)로 간편하게 설정자동 구성(Auto Configuration)라이브러리를 분석해서 필요한 Bean 등을 자동으로 등록관례 기반 설정최소 설정만으로 동작 가능, 필요 시 재정의 가능 (Convention over Configuration)\n\n🔹 3. 운영환경(프로덕션) 기능 내장\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n기능설명Actuator메트릭, 헬스 체크, 환경 정보 등 운영에 필요한 기능 제공외부 구성.properties, .yml, 환경 변수, 커맨드라인 등 다양한 구성 방법 지원\n✅ “스프링(Spring)“이라는 단어의 의미\n\n스프링이라는 용어는 문맥에 따라 달리 사용되므로, 정확한 이해가 필요하다.\n\n🔹 다양한 문맥에서의 “스프링”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n표현의미스프링 DI 컨테이너객체 생성 및 의존성 주입을 책임지는 핵심 기술스프링 프레임워크DI, AOP, 트랜잭션, 웹, 데이터 등 핵심 기능을 제공하는 기본 플랫폼스프링 부트 &amp; 생태계 전체스프링 프레임워크 + 스프링 부트 + 스프링 데이터, 시큐리티, 배치 등 다양한 확장 기술들을 아우르는 스프링 생태계 (Spring Ecosystem)\n\n✅ 스프링의 핵심 개념 (철학)\n\n스프링은 단순한 기능 집합이 아닌, 좋은 객체 지향 애플리케이션을 만들기 위한 철학을 담은 프레임워크다.\n\n🔹 객체 지향과 스프링\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n개념설명자바는 객체 지향 언어클래스, 상속, 다형성, 캡슐화를 지원하여 구조적인 프로그램 설계 가능스프링은 자바의 객체 지향 철학을 극대화의존성 주입(DI)을 통해 객체 간 결합도를 낮추고, 유연하고 테스트 가능한 구조 제공관심사의 분리(Separation of Concerns)비즈니스 로직과 부가적인 기능(트랜잭션, 보안 등)을 AOP 등을 통해 분리 가능설계 유도 프레임워크스프링은 개발자에게 좋은 설계 방식을 자연스럽게 유도함 (SOLID 원칙과 친화적)\n✅ 객체 지향 프로그래밍과 스프링의 관계\n\n스프링은 객체 지향 프로그래밍(OOP)의 핵심 원칙을 실질적으로 구현하고 촉진시키는 프레임워크다.\n\n\n🔹 1. 객체 지향 원칙 적용: OCP + DIP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n원칙설명스프링과의 연결OCP (Open/Closed Principle)  확장에는 열려 있고, 변경에는 닫혀 있어야 한다기존 코드를 수정하지 않고 새로운 기능을 확장 가능새로운 구현체(빈)를 주입하여 기능 확장 가능DIP (Dependency Inversion Principle)  구체 클래스가 아닌 인터페이스에 의존해야 한다고수준 모듈이 저수준 모듈에 의존하지 않도록인터페이스 + 의존성 주입(DI) 구조로 DIP 실현\n\n🔹 2. 스프링의 기술적 지원\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n기능역할효과DI (Dependency Injection)객체 간 의존관계를 외부에서 주입객체의 결합도 ↓, 테스트 용이성 ↑DI 컨테이너 (ApplicationContext)의존성 주입과 생명주기를 자동으로 관리하는 객체 저장소개발자가 객체 생성/연결 직접 안 해도 됨@Component / @Service / @Repository / @Autowired스프링에서 제공하는 어노테이션 기반 컴포넌트 스캔 및 주입코드의 간결함과 자동화 수준 ↑\n\n🔹 3. 현실적인 효과\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n예시설명”부품 교체하듯 개발”인터페이스에 의존한 설계 덕분에, 구현체만 바꾸면 클라이언트 코드는 변경 없이 재사용 가능”기능 확장시 기존 코드 변경 없음”OCP 구조로 인해 새로운 기능 추가 시, 기존 로직을 건드리지 않아도 됨”테스트 용이성 향상”DI로 인해 테스트 코드에서 Mock 객체를 손쉽게 주입 가능"},"공부-정리/스프링-핵심-원리---기본편/스프링-핵심-원리---기본편":{"slug":"공부-정리/스프링-핵심-원리---기본편/스프링-핵심-원리---기본편","filePath":"공부 정리/스프링 핵심 원리 - 기본편/스프링 핵심 원리 - 기본편.md","title":"스프링 핵심 원리 - 기본편","links":["공부-정리/스프링-핵심-원리---기본편/01.-객체-지향-설계와-스프링"],"tags":["SpringStudy"],"content":"\n01. 객체 지향 설계와 스프링\n"},"공부-정리/자바-기초/01.-클래스,-객체,-인스턴스":{"slug":"공부-정리/자바-기초/01.-클래스,-객체,-인스턴스","filePath":"공부 정리/자바 기초/01. 클래스, 객체, 인스턴스.md","title":"01. 클래스, 객체, 인스턴스","links":[],"tags":["JavaBasic"],"content":"✅ 클래스, 객체, 인스턴스 정리\n\n🔹 1. 클래스(Class)\n\n정의: 객체를 만들기 위한 설계도, 청사진\n역할: 객체가 가져야 할 **속성(변수)**과 **기능(메서드)**을 정의\n예시: Student 클래스는 이름(name), 나이(age), 공부하다(study) 같은 속성과 기능을 정의\n\nclass Student {\n    String name;\n    int age;\n \n    void study() {\n        System.out.println(&quot;공부 중...&quot;);\n    }\n}\n \n\n🔹 2. 객체(Object)\n\n정의: 클래스를 기반으로 실제로 메모리에 만들어진 실체\n비유: 클래스가 설계도라면, 객체는 건축물\n특징: 속성과 기능을 실제로 가지고 있음\n\nStudent student1 = new Student();  // student1은 객체\n\n🔹 3. 인스턴스(Instance)\n\n정의: 특정 클래스에서 생성된 객체를 그 클래스의 인스턴스라고 부른다\n설명 방식: “A는 B의 인스턴스이다.” → 소속 관계 표현에 사용\n\n// student1은 Student 클래스의 인스턴스이다.\nStudent student1 = new Student();\n \n\n즉, 인스턴스는 객체의 다른 말이지만, 문맥상 소속을 강조할 때 사용\n\n\n핵심 요약\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분설명비유클래스객체를 만들기 위한 설계도건축 설계도객체클래스를 기반으로 생성된 실체실제 건축물인스턴스객체를 표현하는 방식(소속 강조)“이 건물은 이 설계도의 인스턴스다”"},"공부-정리/자바-기초/02.-기본형,-참조형":{"slug":"공부-정리/자바-기초/02.-기본형,-참조형","filePath":"공부 정리/자바 기초/02. 기본형, 참조형.md","title":"02. 기본형, 참조형","links":[],"tags":["JavaBasic"],"content":"✅ 기본형(Primitive Type) vs 참조형(Reference Type)\n\n자바에서 변수에 값을 대입할 때 항상 “값 복사”가 일어난다.\n이때 복사되는 “값”의 종류에 따라 기본형과 참조형으로 나뉜다.\n\n\n🔹 1. 기본형 (Primitive Type)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명저장 값실제 값 자체 저장복사 방식값 자체가 복사되어 전달됨연산산술 연산 가능null 허용❌ 불가능메모리 위치Stack 영역에 저장예시 타입byte, short, int, long, float, double, char, boolean\nint a = 10;\nint b = a;  // b에도 10이 복사됨 (서로 독립)\n\n🔹 2. 참조형 (Reference Type)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명저장 값실제 객체의 주소값(참조값) 저장복사 방식주소값이 복사되어 같은 객체를 가리킴연산산술 연산 불가능null 허용✅ 가능 (→ NullPointerException 위험)메모리 위치Heap에 객체 저장, 참조값은 Stack에 저장예시 타입배열, 클래스, 인터페이스, String, List, Map, 사용자 정의 객체 등\nStudent s1 = new Student();\nStudent s2 = s1;  // 같은 객체를 가리킴 (s1과 s2는 연결됨)\n \ns2.name = &quot;홍길동&quot;;\nSystem.out.println(s1.name);  // 출력: 홍길동\n\n🧹 Garbage Collection &amp; NullPointerException\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n개념설명Garbage Collector더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거NullPointerException참조형 변수에 null이 들어있을 때, 객체 접근 시 발생하는 런타임 에러\nStudent s = null;\ns.study();  // ❌ NullPointerException 발생\n \n\n핵심 요약\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분기본형참조형저장값 자체객체의 참조값(주소)메모리StackHeap + Stack복사값 복사참조값 복사null 허용❌✅GC 대상❌✅ (사용 안 하면 회수됨)"},"공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍":{"slug":"공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍","filePath":"공부 정리/자바 기초/03. 절차 지향 프로그래밍, 객체 지향 프로그래밍.md","title":"03. 절차 지향 프로그래밍, 객체 지향 프로그래밍","links":[],"tags":["JavaBasic"],"content":"✅ 절차 지향 vs 객체 지향 프로그래밍\n\n🔹 1. 절차 지향 프로그래밍 (Procedural Programming)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목내용핵심 관점**절차(순서)**와 명령어의 흐름 중심설계 방식”무엇을 먼저 하고, 그다음엔 무엇을 할까?” 같은 실행 흐름 중심특징데이터와 함수(처리 로직)가 분리되어 있음장점단순한 문제에 적합, 흐름 제어가 직관적단점유지보수 어려움, 코드 중복, 확장성 떨어짐대표 언어C, 초기의 BASIC 등\n\n🔹 2. 객체 지향 프로그래밍 (OOP: Object-Oriented Programming)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목내용핵심 관점객체 중심 – 데이터 + 행동을 묶은 단위설계 방식”어떤 객체가 어떤 역할을 맡고 어떻게 협력할까?”특징객체가 상태(state)와 행위(behavior)를 가짐장점모듈화, 재사용성, 확장성, 유지보수 용이단점초기에 구조 설계가 복잡할 수 있음대표 언어Java, Python, C++, C#, Kotlin 등\n\n🔹 3. 두 패러다임의 핵심 차이\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n비교 항목절차 지향객체 지향중심 요소프로세스(절차)객체와 메시지설계 관점”어떻게 처리할 것인가?&quot;&quot;무엇이 행동할 것인가?”데이터 구조데이터와 함수가 분리됨객체 내부에 데이터와 메서드가 함께 있음변경 유연성구조 변경에 약함구조 변경에 강함 (다형성, 캡슐화 등 덕분)\n\n객체 지향이 실무에서 중요한 이유\n\n대규모 프로젝트는 수많은 개발자, 수많은 기능, 수많은 수정이 동반된다.\n이 복잡성을 잘게 쪼개고, 유연하게 관리하기 위해 객체 지향은 필수적이다.\n\n주요 이점\n\n재사용성 – 객체 단위로 재활용 가능\n모듈화 – 기능별로 코드 분리, 유지보수 쉬움\n확장성 – 새로운 기능 추가 시 기존 코드 수정 최소화\n유지보수 – 버그 수정이나 개선이 국소적으로 가능\n복잡도 관리 – 추상화를 통해 시스템 전체가 명확해짐\n\n\n✅ 좋은 객체 지향 프로그래밍이란?\n\n🔹 객체 지향의 핵심 개념\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n개념설명캡슐화(Encapsulation)데이터와 메서드를 하나로 묶고, 외부에서 직접 접근 못 하도록 제한 (private, getter/setter)상속(Inheritance)기존 클래스의 속성과 기능을 물려받아 새로운 클래스를 생성다형성(Polymorphism)하나의 인터페이스로 여러 구현체를 대체할 수 있는 능력추상화(Abstraction)복잡한 내부 구현은 숨기고, 필요한 인터페이스만 제공메시지 전달(Message Passing)객체 간 메시지(메서드 호출)를 통해 상호작용\n\n🔹 객체 지향 프로그래밍이란?\n\n객체 간의 협력으로 동작하는 소프트웨어를 설계하고 개발하는 방식.\n하나의 커다란 명령어 흐름이 아닌, 객체들의 자율성과 관계를 중심으로 시스템을 구성.\n\n✅ 객체 지향 설계의 5대 원칙 — SOLID\n\nSOLID는 객체 지향 설계를 더욱 견고하고, 유연하고, 유지보수 가능하게 만드는 5가지 원칙의 집합이다.\nRobert C. Martin(“Clean Code”의 저자)이 제안함.\n\n\n🔹 1. S - 단일 책임 원칙 (Single Responsibility Principle, SRP)\n\n정의: 하나의 클래스는 하나의 책임만 가져야 한다\n목표: 변경 이유가 하나뿐인 클래스를 만들 것\n❌ 나쁜 예: UserService가 로그인, 회원가입, 이메일 전송, DB 처리까지 다 담당\n✅ 좋은 예: AuthService, MailService, UserRepository로 분리\n\n\n👉 클래스 하나가 여러 기능을 다 처리하면, 수정 시 다른 기능까지 깨질 위험이 커짐\n\n\n🔹 2. O - 개방-폐쇄 원칙 (Open/Closed Principle, OCP)\n\n정의: 확장에는 열려 있고, 변경에는 닫혀 있어야 한다\n목표: 기능 추가는 쉽게 하되, 기존 코드 수정을 최소화\n❌ 나쁜 예: 새로운 할인 정책이 생길 때마다 DiscountService 내부 코드 if-else 수정\n✅ 좋은 예: DiscountPolicy 인터페이스를 만들고, 새로운 정책을 상속받아 구현\n\n\n👉 새로운 기능은 클래스를 추가해서 구현하고, 기존 클래스는 건드리지 말자\n\n\n🔹 3. L - 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)\n\n정의: 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다\n목표: 상속받은 객체가 부모의 계약을 어기지 않도록\n❌ 나쁜 예: Bird를 상속받은 Penguin 클래스에서 fly() 메서드를 던짐 (펭귄은 못 날아!)\n✅ 좋은 예: FlyingBird와 WalkingBird를 구분한 뒤, 필요시 따로 상속\n\n\n👉 부모 타입으로 자식을 썼을 때 기대한 동작이 깨지면 LSP 위반\n\n\n🔹 4. I - 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)\n\n정의: 클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 한다\n목표: 작고 구체적인 인터페이스로 나누기\n❌ 나쁜 예: Machine 인터페이스에 print(), scan(), fax() 다 들어있음 → 프린터는 fax 기능 필요 없음\n✅ 좋은 예: Printable, Scannable, Faxable 등으로 인터페이스를 나눔\n\n\n👉 하나의 거대한 인터페이스보단 역할별로 쪼개진 인터페이스가 더 유연함\n\n\n🔹 5. D - 의존 역전 원칙 (Dependency Inversion Principle, DIP)\n\n정의: 상위 모듈이 하위 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 한다\n목표: 구현 클래스에 의존하지 말고 인터페이스에 의존\n❌ 나쁜 예: OrderService가 MysqlOrderRepository에 직접 의존\n✅ 좋은 예: OrderRepository 인터페이스에 의존 → 구현은 외부에서 주입\n\n\n👉 DIP를 지키면 **의존성 주입(DI)**이 자연스럽게 따라오고, 테스트/확장성이 폭발적으로 올라감\n\n\nSOLID 요약 테이블\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n원칙이름요약 핵심결과S단일 책임클래스는 하나의 이유로만 변경되어야유지보수 쉬움O개방-폐쇄확장에는 열려 있고, 변경엔 닫혀야기능 확장 쉬움L리스코프 치환자식은 부모를 대체할 수 있어야다형성 안정성I인터페이스 분리인터페이스는 작고 구체적으로불필요한 의존 제거D의존 역전구체 클래스 대신 추상화에 의존DI 기반 유연성"},"공부-정리/자바-기초/04.-생성자":{"slug":"공부-정리/자바-기초/04.-생성자","filePath":"공부 정리/자바 기초/04. 생성자.md","title":"04. 생성자","links":[],"tags":["JavaBasic"],"content":"✅ 생성자(Constructor) 정리\n\n🔹 1. 생성자의 개념과 필요성\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명정의객체가 생성될 때 자동으로 호출되는 메서드목적객체 생성 시 필요한 초기값 설정 및 초기화 작업 수행사용 이유객체 생성과 동시에 필수 값을 설정하고, 무결한 상태의 객체 생성 보장\nMember member = new Member(&quot;user1&quot;, 20, 90); // 생성자 호출과 동시에 상태 설정\n\n🔹 2. 생성자가 없을 때의 문제점\n\n객체 생성 후에 별도로 초기화해야 함\n개발자가 초기화를 깜빡하거나 잘못된 값을 넣으면, 무효 객체가 생성될 위험 있음\n예: null, 0 같은 미완성 상태의 객체(유령 객체) 발생 가능성\n\n\n🔹 3. 생성자의 기본 사용\npublic class Member {\n    String name;\n    int age;\n    int grade;\n \n    // 생성자\n    Member(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n}\n \n\n생성자를 통해 객체 생성 시점에 데이터를 넣도록 강제할 수 있음\n→ 객체의 유효성 보장, 불완전한 상태 방지\n\n\n🔹 4. 생성자 오버로딩 (Constructor Overloading)\n\n같은 이름의 생성자지만, 매개변수의 수나 타입이 다르면 여러 개 선언 가능\n\nMember(String name, int age, int grade) { ... }\nMember(String name, int age) { ... }\nMember(String name) { ... }\n \n\n상황에 따라 필요한 정보만 넘겨도 객체 생성 가능\n코드 중복이 생기기 쉬우므로, 개선이 필요\n\n\n🔹 5. this()를 통한 생성자 호출\n\n생성자 안에서 다른 생성자를 호출할 때 사용.\n중복 제거와 중심 생성자 하나로 통합할 때 유용함.\n\nMember(String name) {\n    this(name, 0, 0);  // 다른 생성자 호출\n}\n\n반드시 생성자 내의 첫 줄에서만 사용 가능\n오버로딩된 생성자 간의 중심 초기화 포인트를 하나로 유지\n\n\n🔹 6. 기본 생성자 (Default Constructor)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명정의매개변수가 없는 생성자자동 생성클래스에 생성자가 하나도 없다면, 자바가 자동으로 제공수동 작성 필요다른 생성자가 하나라도 있으면, 기본 생성자는 자동 생성되지 않음\npublic class ValueData {\n    int value;\n    // 자동 생성되는 기본 생성자: ValueData() {}\n}\n\nTip: 다양한 방식으로 객체 생성할 수 있도록 기본 생성자 + 오버로딩 생성자를 함께 제공하는 것이 실무에서 유용함\n\n\n🔹 7. 실전 예시: Book 클래스\npublic class Book {\n    String title;\n    String author;\n    int page;\n \n    Book() {\n        this(&quot;&quot;, &quot;&quot;, 0);\n    }\n \n    Book(String title, String author) {\n        this(title, author, 0);\n    }\n \n    Book(String title, String author, int page) {\n        this.title = title;\n        this.author = author;\n        this.page = page;\n    }\n \n    void displayInfo() {\n        System.out.println(&quot;제목: &quot; + title + &quot;, 저자: &quot; + author + &quot;, 페이지: &quot; + page);\n    }\n}\nBook b1 = new Book();\nBook b2 = new Book(&quot;Hello Java&quot;, &quot;Seo&quot;);\nBook b3 = new Book(&quot;JPA&quot;, &quot;Kim&quot;, 700);\n\n다양한 방식으로 객체 생성 가능\n내부 초기화는 하나의 생성자에 집중 → this()로 통합\n"},"공부-정리/자바-기초/05.-패키지,-Import":{"slug":"공부-정리/자바-기초/05.-패키지,-Import","filePath":"공부 정리/자바 기초/05. 패키지, Import.md","title":"05. 패키지, Import","links":[],"tags":["JavaBasic"],"content":"✅ 패키지(Package)와 임포트(Import) 정리\n\n🔹 1. 패키지(Package)란?\n\n자바 클래스들을 논리적으로 묶는 이름 공간\n즉, 비슷한 역할을 하는 클래스들을 그룹화해서 정리하는 구조\n\n🔸 사용 목적\n\n클래스 명의 충돌 방지 (다른 라이브러리와 클래스 이름이 같을 수 있음)\n코드의 모듈화, 구조화\n접근 제어자와 함께 캡슐화 수준을 조절 가능 (default 접근자 등)\n\n🔸 예시\npackage pack;\n \npublic class PackageMain1 {\n    public static void main(String[] args) {\n        Data data = new Data();                // 같은 패키지\n        pack.a.User user = new pack.a.User();  // 다른 패키지의 클래스 직접 사용\n    }\n}\n \n\n🔹 2. 패키지 규칙\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n규칙설명폴더 구조와 일치package pack.a; → 실제 파일 경로도 pack/a/ 이어야 함소문자 사용 권장관례적으로 패키지는 모두 소문자로 작성회사 도메인 역순 사용예: com.example.project, org.mycompany.utils 등\n\n🔹 3. 임포트(Import)란?\n\n다른 패키지에 있는 클래스를 현재 클래스에서 사용하기 위한 선언문\n\n🔸 사용 이유\n\n다른 패키지의 클래스를 간단한 이름으로 사용 가능\n코드 가독성 향상\n\n🔸 사용 방법\nimport pack.a.User;   // 특정 클래스만 import\nimport pack.a.*;      // 해당 패키지의 모든 클래스 import\n \n🔸 예시\npackage pack;\n \nimport pack.a.User;\nimport pack.a.*;\n \npublic class PackageMain2 {\n    public static void main(String[] args) {\n        Data data = new Data();    // 같은 패키지\n        User user = new User();    // import로 간단하게 사용\n        Admin admin = new Admin(); // import 덕분에 클래스명만으로 접근 가능\n    }\n}\n \n\n정리 포인트\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n개념설명Package클래스들을 논리적으로 분류해 관리. 실제 디렉토리 구조와 1:1 매칭Import다른 패키지의 클래스를 사용할 때 클래스명을 간결하게 쓸 수 있도록 해주는 선언"},"공부-정리/자바-기초/06.-접근-제어자":{"slug":"공부-정리/자바-기초/06.-접근-제어자","filePath":"공부 정리/자바 기초/06. 접근 제어자.md","title":"06. 접근 제어자","links":[],"tags":["JavaBasic"],"content":"✅ 접근 제어자 (Access Modifier)\n\n클래스, 메서드, 변수 등에 대한 접근 권한을 지정하는 키워드\n객체의 데이터 보호와 캡슐화 구현의 핵심 도구\n\n\n🔹 1. 접근 제어자의 종류와 범위\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n접근 제어자클래스 내같은 패키지다른 패키지 (상속 X)다른 패키지 (상속 O)private✅ 가능❌ 불가❌ 불가❌ 불가(default)  지정 안 함✅ 가능✅ 가능❌ 불가❌ 불가protected✅ 가능✅ 가능❌ 불가✅ 가능public✅ 가능✅ 가능✅ 가능✅ 가능\n\n📌 기본(default) 접근 제어자는 아무 키워드도 쓰지 않은 경우를 의미\n\n\n🔹 2. 캡슐화(Encapsulation)와 접근 제어자\n\n캡슐화란, 객체 내부의 데이터(속성)를 외부에서 직접 접근하지 못하게 감추고,\n객체가 제공하는 기능(메서드)을 통해서만 간접적으로 접근하도록 제한하는 원칙\n\n✅ 캡슐화를 위한 2가지 제어\n1) 속성(데이터)을 숨겨야 한다\n\n필드는 private 으로 선언하여 외부에서 직접 접근하지 못하게 제한\n대신 public 메서드(getter/setter) 를 통해 간접 접근 제공\n\npublic class User {\n    private String name;\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n \n2) 내부 기능을 숨겨야 한다\n\n클래스 내부에서만 사용하는 헬퍼 메서드, 유틸성 로직은 private 또는 protected 로 감춤\n\npublic class Calculator {\n \n    public int calculate(int a, int b) {\n        return add(a, b);  // 내부적으로 add 사용\n    }\n \n    private int add(int a, int b) {\n        return a + b;\n    }\n}\n\n🔹 3. 실전 설계 원칙\n\n객체 지향에서는 정보 은닉 → 의도한 사용만 허용 → 유연한 설계가 중요\n\n📌 핵심 정리\n\n필드는 원칙적으로 private → 메서드를 통해 통제\n내부 전용 기능은 private, 외부 노출은 public\n상속 전용 기능은 protected\n패키지 단위 모듈화가 되어 있다면, default 활용도 고려\n\n\n실무에서의 설계 기준\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n대상권장 접근 제어자이유필드private직접 수정 방지, 데이터 무결성 보장getter/setterpublic or protected접근 통제 및 검증 로직 삽입 가능내부 유틸 메서드private외부 노출 없이 내부 로직 보호상속을 위한 메서드protected상속 전용 기능 제공공용 API 메서드public외부 호출 지점 명확하게 제한"},"공부-정리/자바-기초/07.-자바-메모리-구조와-static":{"slug":"공부-정리/자바-기초/07.-자바-메모리-구조와-static","filePath":"공부 정리/자바 기초/07. 자바 메모리 구조와 static.md","title":"07. 자바 메모리 구조와 static","links":[],"tags":["JavaBasic"],"content":"✅ 자바의 메모리 구조와 static\n🔹 1. 자바 메모리 구조 전체 그림\n\n자바 애플리케이션이 실행될 때 JVM은 메모리를 다음 3가지 주요 영역으로 나누어 관리한다:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n영역설명메서드(Method) 영역클래스(타입) 정보, static 변수, 상수 풀 등 클래스 수준의 데이터 저장스택(Stack) 영역메서드 호출 시 생성되는 스택 프레임 저장. 지역 변수, 매개변수, 임시 데이터 등힙(Heap) 영역new로 생성된 객체(instance) 가 저장됨. 모든 객체는 힙에 존재하며 참조를 통해 접근\n\n🔸 1-1. 메서드(Method) 영역\n\n클래스별 실행 정보 (생성자, 메서드, 변수 선언 등)\nstatic 변수 저장\n런타임 상수 풀 저장\n모든 클래스 당 한 번만 로딩되며 공유\n\n📍 실무 힌트: static 변수는 메서드 영역에 단 한 번만 로딩되기 때문에 전역 상태 관리에 적합하지만, 동시성 주의 필요\n\n🔸 1-2. 스택(Stack) 영역\n\n메서드 호출 시마다 생성되는 스택 프레임을 저장\n각 스레드마다 독립적인 스택을 가짐\n지역 변수, 매개변수, return 값 저장\n메서드 종료 시, 해당 스택 프레임 제거\n\n📍 실무 힌트: 스택 영역은 매우 빠르지만, 일시적인 데이터만 저장됨 (함수 종료 시 소멸)\n\n🔸 1-3. 힙(Heap) 영역\n\nnew 키워드로 생성된 객체(인스턴스)는 모두 힙에 저장됨\n참조 변수는 스택에 저장되고, 실제 객체는 힙에 존재\nGC(Garbage Collector) 가 더 이상 참조되지 않는 객체를 자동 제거\n\n📍 실무 힌트: 힙 메모리는 GC 성능과 밀접 → 불필요한 객체 생성을 피하는 설계가 중요\n\n🔹 2. static 키워드와 메모리 구조\n\nstatic은 객체가 아니라 클래스 수준에서 존재하는 멤버를 의미\n따라서 인스턴스와는 별도로 메서드 영역에 저장된다.\n\npublic class Data3 {\n    public String name;         // 인스턴스 변수 → 힙에 저장\n    public static int count;    // static 변수 → 메서드 영역에 저장\n \n    public Data3(String name){\n        this.name = name;\n        count++;  // static 변수는 모든 인스턴스가 공유\n    }\n}\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분저장 위치특징인스턴스 변수힙(Heap)객체마다 개별 저장, new로 생성 필요static 변수메서드 영역(Method)클래스당 1개, 모든 객체가 공유, 인스턴스 없이 사용 가능지역 변수스택(Stack)메서드 호출 시 생성, 종료되면 소멸\n\n실무 요약\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n상황static 사용 여부모든 인스턴스가 공유해야 하는 값✅ static 적합개별 객체의 고유한 상태를 저장❌ 인스턴스 변수로 선언유틸성 메서드 (예: Math.max())✅ static 메서드로 구현상태를 가지는 서비스 로직❌ static 사용 지양, 인스턴스 설계 필요"},"공부-정리/자바-기초/08.-final":{"slug":"공부-정리/자바-기초/08.-final","filePath":"공부 정리/자바 기초/08. final.md","title":"08. final","links":[],"tags":["JavaBasic"],"content":"✅ final 키워드 정리\n\n🔹 1. final의 기본 개념\n\n한 번 값이 설정되면, 더 이상 변경할 수 없게 만드는 키워드\n의미는 “최종”, “변경 불가”\n\n\n🔹 2. 사용 위치별 정리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n사용 위치적용 대상설명지역 변수메서드 안에서 선언한 변수한 번만 값 할당 가능, 재할당 금지매개변수메서드 파라미터메서드 내부에서 값 변경 금지 (parameter = ... 불가)필드(멤버 변수)클래스 내부 변수객체 생성 시 단 한 번 값 설정 가능 (생성자에서 설정 O)클래스final class상속 금지 (extends 불가)메서드final method오버라이딩 금지 (자식 클래스에서 재정의 불가)\n\n🔹 3. final 지역 변수 예시\nfinal int num = 10;\n// num = 20;  // ❌ 컴파일 에러 (재할당 금지)\n \nvoid method(final int param) {\n    // param = 30; // ❌ 컴파일 에러\n}\n\n재사용 금지를 보장함으로써, 불변성(inmutability) 유지\n\n\n🔹 4. static final → 상수(Constant)\n\n프로그램 전체에서 공유되고, 절대 변경되지 않아야 할 값을 정의할 때 사용\n\npublic class Constants {\n    public static final double PI = 3.14;\n    public static final int MAX_USERS = 2000;\n}\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키워드의미final값 변경 불가static클래스 차원에서 공유, 메서드 영역 저장\n\n실무에서는 상수 클래스로 모아놓고, 설정값이나 코드 의미를 명확하게 할 때 자주 사용됨\n\n\n🔹 5. final과 참조형 변수\nfinal Data data = new Data();\ndata.value = 10; // ✅ 가능\ndata = new Data(); // ❌ 컴파일 에러\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분가능 여부설명참조 주소 변경❌ 불가data = new Data() 금지참조 대상의 내부 값 변경✅ 가능data.value = 10 등은 가능\n\n참조형 변수에 final을 사용하면 “참조 주소 변경 불가”일 뿐, 내부 값은 변경 가능하다.\n\n\n🔹 6. final을 사용하는 이유\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목적설명불변성 보장실수로 값 변경하는 것 방지 (버그 예방)안정성 향상상수 값은 변경되면 안 되므로 final로 보호의도 명확화”이 변수는 절대 바뀌면 안 돼”라는 메시지 전달함수형 프로그래밍 스타일 대응Java 8 이후 람다식에서도 final 또는 실질적 final 변수 사용 필수"},"공부-정리/자바-기초/09.-상속":{"slug":"공부-정리/자바-기초/09.-상속","filePath":"공부 정리/자바 기초/09. 상속.md","title":"09. 상속","links":["공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍"],"tags":["JavaBasic"],"content":"✅ 자바의 상속 (Inheritance)\n\n객체 지향 프로그래밍(OOP)의 4대 특성 중 하나\n\n\n🔹 1. 상속이란?\n\n기존 클래스의 필드(변수)와 메서드(기능) 를 새로운 클래스에서 재사용할 수 있도록 해주는 객체 지향의 핵심 개념\n\n\nextends 키워드를 사용\n코드 재사용, 유지보수 용이성, 유연한 확장 가능\n\n\n🔹 2. 상속 구조의 기본 구성\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n용어설명부모 클래스 (Super Class)자식 클래스에게 상속되는 기능과 상태를 제공자식 클래스 (Sub Class)부모 클래스의 기능을 상속받고, 추가적으로 확장 가능\npublic class Car {\n    public void move() {\n        System.out.println(&quot;차를 이동합니다.&quot;);\n    }\n}\n \npublic class ElectricCar extends Car {\n    public void charge() {\n        System.out.println(&quot;충전합니다.&quot;);\n    }\n}\n \n\n🔹 3. 자바의 상속 특징\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명단일 상속만 허용클래스는 하나의 부모 클래스만 상속 가능다이아몬드 문제 방지다중 상속 금지로 메서드 충돌 방지모든 클래스의 최상위는 Object명시하지 않아도 extends Object가 기본\n\n🔹 4. 상속과 메모리 구조\n\n\n객체 생성 시 부모 클래스의 메모리 영역도 함께 생성\n메서드 호출 시:\n\n자식 클래스에서 먼저 찾고,\n없으면 부모 클래스에서 찾는다.\n끝까지 못 찾으면 컴파일 오류\n\n\n\n\n🔹 5. 메서드 오버라이딩 (Overriding)\n\n상속받은 메서드를 자식 클래스에서 재정의\n\n@Override\npublic void move() {\n    System.out.println(&quot;전기차가 빠르게 이동합니다.&quot;);\n}\n \n📌 오버라이딩 조건\n\n이름, 매개변수, 반환 타입 모두 동일해야 함\n접근 제어자는 더 넓거나 같아야 함 (예: protected → public 가능)\nstatic, final, private 메서드는 오버라이딩 불가\n생성자는 오버라이딩할 수 없음\n\n\n🔹 6. 오버로딩 vs 오버라이딩\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분설명오버로딩같은 이름, 다른 매개변수 → 메서드 중복 정의오버라이딩상속 관계, 같은 시그니처 → 기존 메서드 재정의\n\n🔹 7. protected 접근 제어자와 상속\n\nprotected는 같은 패키지 or 상속관계에서 접근 가능\n다른 패키지여도 extends 관계라면 사용 가능\n\n// 부모 클래스\nprotected void openDoor() { ... }\n \n// 자식 클래스 (다른 패키지여도 호출 가능)\nthis.openDoor();\n \n\n🔹 8. 상속의 장점과 주의점\n✅ 장점\n\n코드 중복 제거\n기능 확장 용이 (새로운 자식 타입만 추가하면 됨)\n유지보수성과 확장성 향상\n\n⚠️ 주의점\n\n너무 깊은 상속 구조는 복잡도 ↑\n“is-a” 관계가 성립할 때만 상속 사용 (ElectricCar is-a Car)\n잘못된 상속은 오히려 결합도 증가 및 재사용성 저하\n"},"공부-정리/자바-기초/10.-다형성":{"slug":"공부-정리/자바-기초/10.-다형성","filePath":"공부 정리/자바 기초/10. 다형성.md","title":"10. 다형성","links":["공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍"],"tags":["JavaBasic"],"content":"✅ 다형성 (Polymorphism)\n\n객체 지향 프로그래밍(OOP)의 4대 특성 중 하나\n\n\n🔹 1. 다형성이란?\n\n다양한 형태를 가질 수 있는 능력\n하나의 타입(보통 부모 타입)으로 여러 실제 객체(자식)를 참조할 수 있음\n객체 간 공통 인터페이스(타입) 를 통해 확장성, 유연성, 추상화를 극대화함\n\n\n🔹 2. 다형성의 두 축\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n개념설명다형적 참조 (Polymorphic Reference)부모 타입의 참조 변수로 자식 인스턴스를 참조 가능메서드 오버라이딩 (Method Overriding)자식 클래스가 부모 클래스의 메서드를 재정의하면, 호출 시 자식 메서드가 실행됨\n\n✅ 다형적 참조\nParent poly = new Child(); // 업캐스팅\npoly.parentMethod();       // 가능\n// poly.childMethod();     // 불가능 (컴파일 에러)\n\n부모 타입 참조 변수는 자식 객체를 담을 수 있다 (업캐스팅)\n하지만 참조 타입 기준으로만 접근 가능 → 자식의 고유 기능은 보이지 않음\n\n\n🔸 다운캐스팅\nChild child = (Child) poly;\nchild.childMethod();  // 가능\n\n참조 타입을 자식 타입으로 명시적 형변환(캐스팅) 해야 자식 기능 사용 가능\n주의: 부모 타입 참조가 실제로 자식 인스턴스일 때만 가능\n그렇지 않으면 ClassCastException (런타임 오류) 발생\n\n\n🔸 instanceof 키워드\n\n안전한 다운캐스팅을 위한 전처리\n\nif (parent instanceof Child) {\n    ((Child) parent).childMethod();\n}\n\n객체가 해당 타입의 인스턴스인지 확인\nnull도 항상 false 반환\n\n\n✅ 메서드 오버라이딩과 다형성\nParent poly = new Child();\npoly.method();  // 자식 메서드 실행됨\n\n메서드는 실제 인스턴스(객체) 기준으로 동작\n부모 타입으로 호출해도 자식이 재정의(오버라이딩)한 메서드가 실행됨\n\n\n🔸 변수는 오버라이딩되지 않는다\nParent poly = new Child();\nSystem.out.println(poly.value); // Parent의 value 출력\n \n\n필드는 참조 타입 기준, 메서드는 실제 객체 기준\n이 차이는 실무에서 자주 실수하는 부분 중 하나\n\n\n🔸 오버라이딩의 우선 순위\n\n부모 → 자식 → 손자 순으로 오버라이딩 가능\n하위 클래스의 메서드가 항상 우선 호출됨\n\n\n✅ 실전에서의 다형성 활용\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n상황다형성 이점전략 패턴, 서비스 구현체 교체인터페이스 기반 설계로 구현체 교체만으로 기능 변경 가능스프링의 의존성 주입(DI)부모 타입으로 주입 → 구현체 교체에 유연함확장성과 유지보수새로운 타입 추가해도 기존 로직 변경 거의 없음\n\n📌 예: 스프링 DI에서의 다형성\n@Service\npublic class OrderService {\n    private final DiscountPolicy discountPolicy;\n \n    public OrderService(DiscountPolicy discountPolicy) {\n        this.discountPolicy = discountPolicy; // 다형성 적용\n    }\n}\n\nDiscountPolicy는 인터페이스\nRateDiscountPolicy, FixDiscountPolicy 등 구현체만 바꾸면 동작 변경\n\n\n🔺 주의할 점\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n위험 요소설명잘못된 다운캐스팅instanceof 없이 무작정 캐스팅 → 런타임 에러 유발필드 접근 혼동필드는 참조 타입 기준으로 접근 → 혼동 주의불필요한 다운캐스팅 남발설계 구조가 잘못되었을 수 있음 → 인터페이스/추상화 설계로 해결할 것\n"},"공부-정리/자바-기초/11.-다형성-활용":{"slug":"공부-정리/자바-기초/11.-다형성-활용","filePath":"공부 정리/자바 기초/11. 다형성 활용.md","title":"11. 다형성 활용","links":[],"tags":["JavaBasic"],"content":"✅ 다형성 활용\n\n🔹 1. 다형성의 핵심 요약\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n키워드설명다형적 참조부모 타입 참조 변수로 자식 인스턴스를 참조할 수 있음오버라이딩자식 클래스가 부모 메서드를 재정의 → 부모 타입으로 호출해도 자식 메서드 실행\nAnimal[] animals = { new Dog(), new Cat(), new Cow() };\nfor (Animal animal : animals) {\n    animal.sound();  // 각 타입에 맞는 sound() 실행\n}\n\n다형성을 활용하면 유지보수와 확장성이 뛰어난 구조를 만들 수 있음\n\n\n✅ 추상 클래스 (abstract class)\n\n🔸 추상 클래스란?\n\n실체화할 수 없는 클래스\n”공통 로직 + 오버라이딩 강제”를 동시에 제공할 수 있는 상속 설계 도구\n\npublic abstract class Animal {\n    public abstract void sound();  // 추상 메서드 (오버라이딩 강제)\n    \n    public void move() {\n        System.out.println(&quot;동물이 움직입니다.&quot;);\n    }\n}\n \n🔸 특징\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명인스턴스화❌ 불가능 (new Animal() 불가)목적공통 기능 + 추상 기능 혼합 제공상속 시반드시 추상 메서드 오버라이딩 필요활용상속 계층 구조에서 공통 기능 제공 + 확장 설계 가능\n\n✅ 인터페이스 (interface)\n\n🔸 인터페이스란?\n\n순수한 추상화(기능 정의만) 제공하는 타입. 다형성과 다중 구현을 위한 설계 도구\n\npublic interface InterfaceAnimal {\n    void sound(); // public abstract 생략됨\n    void move();\n}\n🔸 특징\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명인스턴스화❌ 불가능모든 메서드public abstract → 생략 가능모든 변수public static final → 상수만 가능다중 구현✅ 가능 → 클래스는 다중 상속 불가지만 인터페이스는 다중 구현 가능주 사용 목적다형성 설계, 역할 위임, DI(의존성 주입) 등\n\n🔸 다중 구현의 안전성\npublic class Child implements InterfaceA, InterfaceB {\n    @Override public void methodCommon() { ... }\n}\n\n인터페이스는 구현 내용을 가지지 않기 때문에 충돌 없음\n구현 충돌 가능성이 없으므로 다중 구현이 안전하고, 자바는 이를 허용\n\n\n\n✅ 클래스 / 추상 클래스 / 인터페이스 비교\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분클래스추상 클래스인터페이스인스턴스화✅ 가능❌ 불가❌ 불가상속단일 상속단일 상속다중 구현 가능메서드구현 O구현 + 추상 혼합모두 추상 (Java 8 이상 default 메서드 가능)변수자유롭게 선언자유롭게 선언모두 public static final (상수)목적실체 클래스공통 기능 + 확장 설계순수 역할 정의, 다형성 지원사용 예단독 사용계층 구조 설계다형성 기반 설계, 전략 패턴 등\n\n🔎 언제 무엇을 쓸까?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n상황추천공통 기능 + 확장 구조 설계🔸 추상 클래스역할만 정의하고 구현은 다양하게 처리🔸 인터페이스구체 동작과 상태를 모두 관리해야 함🔸 일반 클래스"},"공부-정리/자바-기초/12.-다형성과-설계":{"slug":"공부-정리/자바-기초/12.-다형성과-설계","filePath":"공부 정리/자바 기초/12. 다형성과 설계.md","title":"12. 다형성과 설계","links":[],"tags":["JavaBasic"],"content":"✅ 다형성과 설계\n\n🔹 1. 다형성의 실생활 비유 – “역할과 구현”\n\n“역할(인터페이스)과 구현(구체 클래스)을 구분해야 유연한 세상이 된다.”\n\n🧍 예: 운전자의 관점\n운전자는 &#039;차&#039;라는 역할만 알면 된다.\n그 차가 전기차든, 수소차든, 자율주행차든 몰라도 된다.\n\n**운전자(코드)**는 차 인터페이스에만 의존하고\n실제 구현은 다양한 Car 클래스가 담당\n\n\n👉 다형성은 역할(interface)을 기준으로 구현체(class)를 바꿔치기할 수 있는 능력이다.\n\n\n🔹 2. 역할(인터페이스)과 구현(클래스)의 분리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분의미예시역할 (interface)“무엇을 할 수 있는가”만 정의interface Car { void move(); }구현 (class)실제로 “어떻게 동작할 것인가”class ElectricCar implements Car\npublic interface Car {\n    void move();\n}\n \npublic class ElectricCar implements Car {\n    public void move() {\n        System.out.println(&quot;전기차가 움직입니다.&quot;);\n    }\n}\n\n🔹 3. 다형성에 기반한 설계의 장점\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n장점설명✅ 확장성새로운 클래스 추가 시 기존 코드 변경 X✅ 유지보수성구현체 교체해도 역할만 지키면 문제 없음✅ 유연성런타임에 객체 주입 가능 (전략 패턴, DI 등)✅ 테스트 용이성역할(interface)에 가짜 구현(Mock)만 만들어도 테스트 가능\n\n🔹 4. 다형성과 의존 역전 원칙 (DIP)\n\n구현이 아닌 추상(역할) 에 의존해야 유연한 설계가 가능하다\n\n// ❌ 잘못된 설계\npublic class Driver {\n    private final ElectricCar car = new ElectricCar();\n}\n \n// ✅ 다형성을 활용한 좋은 설계\npublic class Driver {\n    private final Car car;\n \n    public Driver(Car car) {\n        this.car = car;\n    }\n}\n\n이 설계는 Car라는 인터페이스에 의존 → 어떤 구현이든 교체 가능\n실무에서는 스프링이 이 구조를 자동으로 주입 (@Autowired + DI)\n\n\n🔹 5. 다형성과 스프링 프레임워크\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구조설명컨트롤러/서비스/레포지토리모두 역할 중심(interface) 으로 설계의존성 주입(DI)다형적 참조 기반으로 런타임에 구현 객체 결정전략 패턴, 템플릿 콜백, 프록시다형성을 극단적으로 활용한 구조 설계\n@Service\npublic class PaymentService {\n    private final PayPolicy policy;\n \n    public PaymentService(PayPolicy policy) {\n        this.policy = policy;\n    }\n}\n\n다양한 정책(KakaoPay, TossPay)을 PayPolicy로 다형성 처리 가능\n\n\n🔹 6. 실전 설계 팁 – 언제 인터페이스를 만들까?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n기준설명변화 가능성이 있다정책, 전략, 교체될 가능성이 있다면 인터페이스로 추상화테스트를 독립적으로 하고 싶다Mock 객체로 대체하려면 역할이 필요상위 계층에 하위 구현을 숨기고 싶다의존 역전 구조 필요\n\n다형성과 설계 정리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n항목설명핵심 키워드역할, 구현 분리, 인터페이스, 추상화, 유연성설계 원칙DIP, OCP, SRP 등 SOLID 원칙을 다형성으로 구현실전 효과확장에 강하고, 테스트하기 쉽고, 유지보수가 쉬움"},"공부-정리/자바-기초/자바-기초":{"slug":"공부-정리/자바-기초/자바-기초","filePath":"공부 정리/자바 기초/자바 기초.md","title":"자바 기초","links":["공부-정리/자바-기초/01.-클래스,-객체,-인스턴스","공부-정리/자바-기초/02.-기본형,-참조형","공부-정리/자바-기초/03.-절차-지향-프로그래밍,-객체-지향-프로그래밍","공부-정리/자바-기초/04.-생성자","공부-정리/자바-기초/05.-패키지,-Import","공부-정리/자바-기초/06.-접근-제어자","공부-정리/자바-기초/07.-자바-메모리-구조와-static","공부-정리/자바-기초/08.-final","공부-정리/자바-기초/09.-상속","공부-정리/자바-기초/10.-다형성","공부-정리/자바-기초/11.-다형성-활용","공부-정리/자바-기초/12.-다형성과-설계"],"tags":["JavaStudy"],"content":"\n01. 클래스, 객체, 인스턴스\n02. 기본형, 참조형\n03. 절차 지향 프로그래밍, 객체 지향 프로그래밍\n04. 생성자\n05. 패키지, Import\n06. 접근 제어자\n07. 자바 메모리 구조와 static\n08. final\n09. 상속\n10. 다형성\n11. 다형성 활용\n12. 다형성과 설계\n"},"공부-정리/자바-중급/00.-java.lang-패키지":{"slug":"공부-정리/자바-중급/00.-java.lang-패키지","filePath":"공부 정리/자바 중급/00. java.lang 패키지.md","title":"00. java.lang 패키지","links":[],"tags":["JavaMid"],"content":"java.lang\n\n자바가 기본으로 제공하는 라이브러리 중에 가장 기본이 되는 것\nlang 은 language 의 줄임말\n가장 기본이 되는 패키지로써 import 가 생략 된다.\n\njava.lang 패키지의 대표적인 클래스\n\nObject : 모든 자바 객체의 부모 클래스\nString : 문자열\nInteger, Long등등 : 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것\nClass : 클래스 메타 정보\nSystem : 시스템과 관련된 기본 기능들을 제공\n"},"공부-정리/자바-중급/01.-Object-클래스":{"slug":"공부-정리/자바-중급/01.-Object-클래스","filePath":"공부 정리/자바 중급/01. Object 클래스.md","title":"01. Object 클래스","links":[],"tags":["JavaMid"],"content":"Object 클래스는 최상위 부모 클래스\n\n부모가 없으면 묵시적으로 Object 클래스를 상속 받는다.\n\n묵시적 : 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행\n명시적 : 개발자가 코드에 직접 기술해서 작동\n\n\n\nObject 클래스의 필요성\n공통 기능 제공\n\n객체의 정보 제공 (toString())\n다른 객체와 같은지 비교 가능 (equals())\n객체가 어떤 클래스로 만들어졌는지 확인 (getClass())\n기타 등등\n\n다형성의 기본 구현\n\nObject 클래스는 모든 객체를 다 담을 수 있는 최상위 클래스이기 때문에 다형성을 지원하는 기본적인 메커니즘을 제공한다.\n"},"공부-정리/자바-중급/02.-불변-객체":{"slug":"공부-정리/자바-중급/02.-불변-객체","filePath":"공부 정리/자바 중급/02. 불변 객체.md","title":"02. 불변 객체","links":[],"tags":["JavaMid"],"content":"불변 객체란?\n\n객체의 상태가 변하지 않는 객체\n\npublic class Address {  //가변 객체\n  \n    private String value;  \n  \n    public Address(String value) {  \n        this.value = value;  \n    }  \n  \n    public String getValue() {  \n        return value;  \n    }  \n  \n    public void setValue(String value) {  \n        this.value = value;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return &quot;Address{&quot; +  \n                &quot;value=&#039;&quot; + value + &#039;\\&#039;&#039; +  \n                &#039;}&#039;;  \n    }  \n}\npublic class ImmutableAddress {  //불변 객체\n  \n    private final String value;  \n  \n    public ImmutableAddress(String value) {  \n        this.value = value;  \n    }  \n  \n    public String getValue() {  \n        return value;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return &quot;Address{&quot; +  \n                &quot;value=&#039;&quot; + value + &#039;\\&#039;&#039; +  \n                &#039;}&#039;;  \n    }  \n}\n\n위의 예제에서 final 을 이용하여 불변 객체를 만들었지만 꼭 final 을 사용하지 않더라도 객체 내부에 변화가 없게 설계한다면 그것이 불변 객체 이다\n\n가변 객체 vs 불변 객체\n\n가변은 처음 만든 이후 상태가 변할 수 있다는 뜻 ( ex. Address 클래스 )\n불변은 처음 만든 이후 상태가 변하지 않는다는 뜻 ( ex. ImmutableAddress 클래스 )\n\n불변 객체 사용 예시\npublic class ImmutableObj {  \n  \n    private final int value;  \n  \n    public ImmutableObj(int value) {  \n        this.value = value;  \n    }  \n  \n    public ImmutableObj add(int addValue) {  \n        return new ImmutableObj(value + addValue);  \n    }  \n  \n    public int getValue() {  \n        return value;  \n    }  \n}\n\nvalue 는 final 로 변하지 않게 만들면서 값에 변화를 주고 싶다면 add 메서드를 호출하여 새로운 객체를 생성하여 반환한다.\n\n불변으로 설계하는 이유\n\n캐시 안전성\n멀티 쓰레드 안정성\n엔티티의 값 타입\n"},"공부-정리/자바-중급/03.-String-클래스":{"slug":"공부-정리/자바-중급/03.-String-클래스","filePath":"공부 정리/자바 중급/03. String 클래스.md","title":"03. String 클래스","links":["공부-정리/자바-중급/02.-불변-객체"],"tags":["JavaMid"],"content":"String?\n\n자바에서 문자를 다루는 대표적인 타입은 기본형의 char, 참조형의 String 이 있다.\nString 은 여러개의 char가 나열된 것으로도 볼수 있다.\n실제로 String 클래스에 가보면 자바 9버전 이전에는 char 의 모임인것을 확인할 수 있다.\n\npublic final class String  \n    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,  \n               Constable, ConstantDesc {\n\tprivate final char[] value;   //자바 9버전 이하\n \n\tprivate final byte[] value;   //자바 9버전 이상\n           \n}\n\n자바 9버전 이상에서 byte[] 배열의 집합인 이유는 영어나 숫자는 1바이트를 사용하는데 char를 사용하면 2바이트씩 사용하게 되기 때문에 메모리 손실이 발생한다. 그렇기 때문에 byte 를 이용하여 영어로만 된 문자열이나 숫자가 들어간 문자열을 효율적으로 메모리 관리를 한다.\n\nString 클래스 간의 비교\n\nString 클래스는 기본형이 아닌 참조형이므로 동일성 비교 ( == ) 가 아닌 동등성 비교 ( equals() ) 를 해야 한다.\nnew String() 으로 객체 생성이 아닌 String str = &quot;Hello&quot;  이런식으로 문자열 리터럴을 사용하면 ( == ) 을 사용해도 문자열이 같은지 비교가 가능하지만 개발자가 항상 new String() 으로 문자열을 생성했는지, 문자열 리터럴로 생성했는지 확인하기 번거로우니 항상 equals() 를 사용하도록 하자.\n\n문자열 리터럴을 사용하면 ( == ) 이 성립하는 이유\n\n\n자바에서는 문자열 리터럴을 사용하는 경우 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다.\n\n\n\n자바가 실행되는 시점에 클래스에 문자열 리터럴이 존재하는 경우, 문자열 풀에 String 인스턴스를 미리 만들어 둔 후, 같은 문자열이 있으면 만들지 않는다.\n\n\nstr3 과 str4에 동일한 문자열이 존재할 경우 같은 객체를 참조하고 있기 떄문에 ( == ) 으로도 true 가 되는 것이다.\n\n\n불변 객체\nString은 불변 객체이다.\npublic class StringImmutable1 {  \n  \n    public static void main(String[] args) {  \n        String str = &quot;hello&quot;;  \n        str.concat(&quot; java&quot;);  \n        System.out.println(&quot;str = &quot; + str);  \n    }  \n}\n\nconcat 메서드를 사용하여 문자열을 추가하는 코드를 짠다고 한들 str 의 결과값이 hello java 가 아닌 hello 가 된다. 그 이유는 String이 불변 객체이기 때문이다.\nhello java의 결과값을 얻기 위해서는 따로 String 변수에 받아줘야 한다.\n\n주요 메서드\n문자열 정보 조회\n\nlength(): 문자열의 길이를 반환한다.\nisEmpty(): 문자열이 비어 있는지 확인한다. (길이가 0)\nisBlank(): 문자열이 비어 있는지 확인한다. (길이가 0이거나 공백(Whitespace)만 있는 경우), 자바 11 charAt(int index): 지정된 인덱스에 있는 문자를 반환한다.\n\n문자열 비교\n\nequals(Object anObject): 두 문자열이 동일한지 비교한다.\nequalsIgnoreCase(String anotherString): 두 문자열을 대소문자 구분 없이 비교한다.\ncompareTo(String anotherString): 두 문자열을 사전 순으로 비교한다.\ncompareToIgnoreCase(String str): 두 문자열을 대소문자 구분 없이 사전적으로 비교한다.\nstartsWith(String prefix): 문자열이 특정 접두사로 시작하는지 확인한다.\nendsWith(String suffix): 문자열이 특정 접미사로 끝나는지 확인한다.\n\n문자열 검색\n\ncontains(CharSequence s): 문자열이 특정 문자열을 포함하고 있는지 확인한다.\nindexOf(String ch) /  indexOf(String ch, int fromIndex): 문자열이 처음 등장하는 위치를반환한다.\nlastIndexOf(String ch): 문자열이 마지막으로 등장하는 위치를 반환한다.\n\n문자열 조작 및 변환\n\nsubstring(int beginIndex) /  substring(int beginIndex, int endIndex): 문자열의 부분문자열을 반환한다.\nconcat(String str): 문자열의 끝에 다른 문자열을 붙인다.\nreplace(CharSequence target, CharSequence replacement): 특정 문자열을 새 문자열로 대체한다.\nreplaceAll(String regex, String replacement): 문자열에서 정규 표현식과 일치하는 부분을 새문자열로 대체한다.\nreplaceFirst(String regex, String replacement): 문자열에서 정규 표현식과 일치하는 첫 번째부분을 새 문자열로 대체한다.\ntoLowerCase() /  toUpperCase(): 문자열을 소문자나 대문자로 변환한다.\ntrim(): 문자열 양쪽 끝의 공백을 제거한다. 단순 Whitespace만 제거할 수 있다.\nstrip(): Whitespace와 유니코드 공백을 포함해서 제거한다. 자바 11\n\n문자열 분할 및 조합\n\nsplit(String regex): 문자열을 정규 표현식을 기준으로 분할한다.\njoin(CharSequence delimiter, CharSequence... elements): 주어진 구분자로 여러 문자열을결합한다.\n\n기타 유틸리티\n\nvalueOf(Object obj): 다양한 타입을 문자열로 변환한다.\ntoCharArray(): 문자열을 문자 배열로 변환한다.\nformat(String format, Object... args): 형식 문자열과 인자를 사용하여 새로운 문자열을 생성한다.\nmatches(String regex): 문자열이 주어진 정규 표현식과 일치하는지 확인한다.\n\nStringBuilder\n\n불변인 String 클래스와 달리 StringBuilder 는 가변적인 클래스\n가변이므로 StringBuilder 사용 시 사이드 이펙트에 주의하여 사용하여야 한다.\n보통 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면 안전한 (불변인) String으로 변환하는 것이 좋다.\n\n주요 메서드\n\nappend() : 문자열 추가\ninsert() : 특정 위치에 문자열 삽입\ndelete() : 특정 범위의 문자열 삭제\nreverse() : 문자열 뒤집기\ntoString() : 원하는 문자열을 만든 후 String을 생성하여 반환\n\nString 보다 StringBuilder를 사용하는 것이 좋은 경우\n\n반복문에서 반복해서 문자를 연결할 경우\n조건문을 통해 동적으로 문자열을 조합할 경우\n복잡한 문자열의 특정 부분을 변경해야 할 경우\n매우 긴 대용량 문자열을 다룰 경우\n\nString vs StringBuilder vs StringBuffer\n\nString\n\n장점 : 불변성으로 인해 안전하며, HashMap 키와 같은 곳에 사용하기 적합.\n단점 : 문자열을 자주 변경하면 새로운 객체를 생성하므로 성능 및 메모리 낭비 발생.\n\n\nStringBuilder\n\n장점 : 문자열 조작이 빠르고 효율적이며 단일 스레드 환경에서 적합.\n단점 : 동기화를 제공하지 않아 멀티스레드 환경에서 안전하지 않음.\n\n\nStringBuffer\n\n장점 : 스레드에 안전하며 멀티스레드 환경에서 적합.\n단점 : 동기화로 인해 단일 스레드 환경에서 StringBuilder보다 성능이 떨어짐.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n특징StringStringBuilderStringBuffer불변성불변가변가변스레드 안전성스레드에 안전하지 않음스레드에 안전하지 않음스레드에 안전함성능상대적으로 느림가장 빠름StringBuilder 보다 느림동기화불필요동기화를 제공하지 않음동기화 제공사용 상황문자열을 자주 변경하지 않을 때문자열을 자주 변경할 때멀티스레드 환경에서 문자열 변경 시메모리 사용불변성으로 인해 메모리 낭비 가능효율적동기화 오버헤드로 메모리 사용 증가 가능"},"공부-정리/자바-중급/04.-래퍼-클래스":{"slug":"공부-정리/자바-중급/04.-래퍼-클래스","filePath":"공부 정리/자바 중급/04. 래퍼 클래스.md","title":"04. 래퍼 클래스","links":[],"tags":["JavaMid"],"content":"기본형의 한계\n\n자바는 객체 지향 언어이지만, int, boolean 같은 기본형은 객체가 아니기 때문에 아래와 같은 한계가 있다.\n\n객체가 아니기 때문에 메서드 제공, 객체 참조가 필요한 컬렉션 프레임워크 사용 불가, 제네릭 사용 불가와 같은 한계가 존재한다.\n기본형은 항상 데이터를 가지고 있어야 하므로 null값을 가질 수 없다.\n\n\n\n래퍼 클래스 란?\n\n기본형을 객체로 감싸( wrap ) 객체로서 사용하기 위해 사용된다.\n래퍼 클래스 종류\n\nbyte → Byte\nshort → Short\nint → Integer\nlong → Long\nfloat → Float\ndouble → Double\nchar → Character\nboolean → Boolean\n\n\n래퍼 클래스 특징\n\n불변\n비교 시 equals() 사용\n\n\n\n오토 박싱\n\n기본형과 래퍼 클래스가 같은 종류 일 경우 ( ex. int ←&gt; Integer ) 오토 박싱과 오토 언박싱을 지원한다.\n\npublic class AutoboxingMain2 {  \n  \n    public static void main(String[] args) {  \n        // Primitive -&gt; Wrapper  \n        int value = 7;  \n        //Integer boxedValue = Integer.valueOf(value); \n        Integer boxedValue = value; // 오토 박싱\n  \n        // Wrapper -&gt; Primitive        \n        //int unboxedValue = boxedValue.intValue();\n        int unboxedValue = boxedValue; // 오토 언박싱\n    }  \n}\n주요 메서드\n\nvalueOf() : 래퍼 타입 반환\nparseInt() : 문자열을 기본형으로 변환 ( Integer를 예로 들었기 때문이지 double로 변환 시 parseDouble() 같이 parse뒤에 변경 원하는 기본형 타입을 넣어야 한다. )\ncompareTo() : 내 값과 인수로 넘어온 값을 비교하여 내 값이 크면 1, 같으면 0, 작으면 -1을 반환한다.\nsum(), min(), max() : static 메서드로서 간단한 덧셈, 최소값, 최대값 연산을 수행한다.\n"},"공부-정리/자바-중급/05.-Class-클래스":{"slug":"공부-정리/자바-중급/05.-Class-클래스","filePath":"공부 정리/자바 중급/05. Class 클래스.md","title":"05. Class 클래스","links":[],"tags":["JavaMid"],"content":"주요 기능\n\n타입 정보 얻기: 클래스의 이름, 슈퍼클래스, 인터페이스, 접근 제한자 등과 같은 정보를 조회할 수 있다.\n리플렉션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고, 이들을 통해 객체 인스턴스를 생성하거나 메서드 를 호출하는 등의 작업을 할 수 있다.\n동적 로딩과 생성: Class.forName() 메서드를 사용하여 클래스를 동적으로 로드하고, newInstance() 메서드를 통해 새로운 인스턴스를 생성할 수 있다.\n애노테이션 처리: 클래스에 적용된 애노테이션(annotation)을 조회하고 처리하는 기능을 제공한다.\n\n주요 메서드\n\ngetDeclaredFields(): 클래스의 모든 필드를 조회한다.\ngetDeclaredMethods(): 클래스의 모든 메서드를 조회한다.\ngetSuperclass(): 클래스의 부모 클래스를 조회한다.\ngetInterfaces(): 클래스의 인터페이스들을 조회한다.\ngetDeclaredConstructor().newInstance() : 생성자를 선택하여 ( getDeclaredConstructor() ) 인스턴스를 만든다 ( .newInstance() )\n"},"공부-정리/자바-중급/06.-System-클래스":{"slug":"공부-정리/자바-중급/06.-System-클래스","filePath":"공부 정리/자바 중급/06. System 클래스.md","title":"06. System 클래스","links":[],"tags":["JavaMid"],"content":"\n시스템과 관련된 기본 기능 제공\n\n주요 필드\n\nin : 표준 입력 표시\nout : 표준 출력 표시\nerr : 표준 오류 스트림 표시\n\n주요 메서드\n\ncurrentTimeMillis() : 현재 시간을 밀리 초 단위로 제공\nnanoTime() : 현재 시간을 나노 초 단위로 제공\ngetenv() : OS 에서 설정한 환경 변수 값 제공\ngetProperties() : 현재 시스템 속성 제공\ngetProperty(String key) : 특정 속성 제공\nexit(int status) : OS 에 프로그램 종료 상태 코드 전달\n\n상태 코드 0 : 정상 종료\n상태 코드가 0이 아님 : 오류나 예외로 인한 종료\n\n\narraycopy() : 배열 복사\n"},"공부-정리/자바-중급/07.-Math,-Random-클래스":{"slug":"공부-정리/자바-중급/07.-Math,-Random-클래스","filePath":"공부 정리/자바 중급/07. Math, Random 클래스.md","title":"07. Math, Random 클래스","links":[],"tags":["JavaMid"],"content":""},"공부-정리/자바-중급/08.-Enum-Type":{"slug":"공부-정리/자바-중급/08.-Enum-Type","filePath":"공부 정리/자바 중급/08. Enum Type.md","title":"08. Enum Type","links":[],"tags":["JavaMid"],"content":"필요성\n\nString 사용 시 타입 안정성 부족과 데이터 일관성이 떨어지는 단점이 있다\nex) “Monday”, “Tuesday” 등 요일만 넣고 싶지만 다른 문자열을 넣어도 오류가 생기지 않고, “Munday” 같은 오타를 넣어도 오류가 발생하지 않는 문제가 발생\n정확하게 특정 범위로 값을 제한하기 위해서 사용한다.\n\n장점\n\n정해진 객체만 사용할 수 있기 때문에 타입 안정성 향상과 데이터 일관성이 보장된다.\n\n특징\n\njava.lang.Enum 을 강제로 상속 받는다.\n이미 java.lang.Enum 을 상속 받았기 때문에 추가로 다른 클래스를 상속 받을 수 없다.\n인테퍼이스를 구현 할 수 있다.\n추상 메서드를 선언하고, 구현할 수 있다.\n\n주요 메서드\n\nvalues() : 모든 ENUM 상수를 포함하는 배열 반환\nvalueOf(String name) : 주어진 이름과 일치하는 ENUM 상수 반환\nname() : ENUM 상수의 이름을 문자열로 반환\nordinal() : ENUM 상수의 선언 순서를 반환\n\n이 메서드는 중간에 상수를 선언하는 위치가 바뀌거나 추가되거나 제거될때 상수의 순서가 바뀔 수 있기 때문에 가급적 사용하지 않는 것이 좋다.\n\n\ntoString() : ENUM 상수의 이름을 문자열로 반환, name() 과 유사하지만 toString()은 직접 오버라이드 할수 있다는 차이점이 있다.\n\n사용 예시 코드\npublic enum AuthGrade {  \n    GUEST(1, &quot;손님&quot;),   \n    LOGIN(2, &quot;로그인 회원&quot;),   \n    ADMIN(3, &quot;관리자&quot;);  \n  \n\tprivate final int level;             //필드는 생성자로만 접근하도록 private로\n    private final String description;    \n  \n    AuthGrade(int level, String description) {  \n        this.level = level;  \n        this.description = description;  \n    }  \n  \n    public int getLevel() {  \n        return level;  \n    }  \n  \n    public String getDescription() {  \n        return description;  \n    }  \n}"},"공부-정리/자바-중급/09.-날짜와-시간":{"slug":"공부-정리/자바-중급/09.-날짜와-시간","filePath":"공부 정리/자바 중급/09. 날짜와 시간.md","title":"09. 날짜와 시간","links":[],"tags":["JavaMid"],"content":"필요성\n\n윤년, 각 달의 일수 등을 모두 고려하여야 하기 때문에 특정 날짜에서 다른 날짜까지의 정확한 일수 계산은 생각보다 복잡하다.\n\n자바 날짜와 시간 라이브러리\n\n\nLocalDate : 날짜만 표현 (2023-11-23)\nLocalTime : 시간만 표현 (08:20:30.123)\nLocalDateTime : LocalDate 와 LocalTime 이 합쳐진 것. 실제로 안에 들어가보면 둘다 사용하고 있다.\nZonedDateTime :  시간대를 고려한 날짜와 시간을 표현 (2023-12-22T08:20:30.213+9:00[Asia/Seoul])\nOffsetDateTime : 시간대를 고려한 날짜와 시간표현. 타임존이 없고 오프셋만 있다. (2023-12-22T08:20:30.213+9:00)\nYear : 년\nMonth : 월\nYearMonth : 년월\nMonthDay : 달일\nDayOfWeek : 월, 화, 수, 목, 금, 토, 일\nInstant : 초 데이터만 포함\nPeriod : 특정 시점의 시간\nDuration : 시간의 간격\n"},"공부-정리/자바-중급/10.-중첩-클래스,-내부-클래스":{"slug":"공부-정리/자바-중급/10.-중첩-클래스,-내부-클래스","filePath":"공부 정리/자바 중급/10. 중첩 클래스, 내부 클래스.md","title":"10. 중첩 클래스, 내부 클래스","links":[],"tags":["JavaMid"],"content":"중첩 클래스란?\n\n클래스 안에 클래스가 있는것\n\n종류\n\n정적 중첩 클래스\n내부 클래스\n\n내부 클래스 : 바깥 클래스의 인스턴스의 멤버에 접근\n지역 클래스 : 내부 클래스의 특징 + 지역 변수에 접근\n익명 클래스 : 지역 변수에 접근 + 클래스의 이름이 없는 특별한 클래스\n\n\n\n사용처\n\n특정 클래스가 다른 하나의 클래스 안에서만 사용될 때 사용\n\n사용하는 이유\n\n논리적 그룹화 : 특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우 해당 클래스 안에 포함하는 것이 논리적으로 더 그룹화\n캡슐화 : 중첩 클래스는 바깥 클래스의 private 멤버에 접근할 수 있다\n\n정적 중첩 클래스\npublic class NestedOuter {  \n  \n    private static int outClassValue = 3;  \n    private int outInstanceValue = 2;  \n  \n    static class Nested{  \n        private int nestedInstanceValue = 1;  \n        public void print(){  \n            //자신의 멤버에 접근  \n            System.out.println(nestedInstanceValue);  \n  \n            //바깥 클래스의 인스턴스 멤버에 접근할 수 없다.  \n            //System.out.println(outInstanceValue);  \n\t\t    //바깥 클래스의 클래스 멤버에는 접근할 수 있다.\n\t\t    System.out.println(outClassValue);  \n        }  \n    }  \n}\n\n앞에 static 키워드가 붙는다\n자신의 멤버에 접근 가능\n바깥 클래스의 인스턴스 멤버에 접근할 수 없음\n바깥 클래스의 클래스 멤버에 접근 가능\n\npublic class NestedOuterMain {  \n  \n    public static void main(String[] args) {  \n        NestedOuter.Nested nested = new NestedOuter.Nested();  \n        nested.print();  \n  \n        System.out.println(&quot;nested Class() = &quot; + nested.getClass());  \n    }  \n}\n\nstatic 이 붙어서 메서드 영역에 생성되므로 바깥 클래스의 인스턴스 정보를 알 필요 없다.\nNestedOuter.Nested nested = new NestedOuter.Nested(); 로 바깥 클래스의 인스턴스 정보 없이 바로 생성 할 수 있다.\n\n내부 클래스\npublic class InnerOuter {  \n    private static int outClassValue = 3;  \n    private int outInstanceValue = 2;  \n  \n    class Inner {  \n        private int innerInstaceValue = 1;  \n        public void print(){  \n            //자기 자신에 접근  \n            System.out.println(innerInstaceValue);  \n            //외부 클래스의 인스턴스 멤버에 접근 가능  \n            System.out.println(outInstanceValue);  \n            // 외부 클래스의 클래스 멤버에도 접근 가능  \n            System.out.println(outClassValue);  \n        }  \n    }  \n}\n\nstatic 이 붙지 않는다.\n바깥 클래스의 인스턴스에 소속된다.\n\npublic class InnerOuterMain {  \n  \n    public static void main(String[] args) {  \n        InnerOuter outer = new InnerOuter();  \n        InnerOuter.Inner inner = outer.new Inner();  \n        inner.print();  \n  \n        System.out.println(&quot;inner.getClass() = &quot; + inner.getClass());  \n    }  \n}\n\n내부 클래스는 바깥 클래스의 인스턴스에 소속되므로 바깥 클래스의 인스턴스 정보를 알아야 생성 가능\n그러므로 InnerOuter outer = new InnerOuter(); 로 바깥 클래스를 생성 후 outer 를 참조하여 InnerOuter.Inner inner = outer.new Inner(); 인스턴스를 생성할 수 있다.\n\n같은 이름의 바깥 변수 접근\npublic class ShadowingMain {  \n    public int value = 1;  \n  \n    class Inner{  \n        public int value = 2;  \n        void go(){  \n            int value = 3;  \n            System.out.println(&quot;value = &quot; + value);  \n            System.out.println(&quot;this.value = &quot; + this.value);  \n            System.out.println(&quot;ShadowingMain.value = &quot; \n            + ShadowingMain.this.value);  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        ShadowingMain main = new ShadowingMain();  \n        Inner inner = main.new Inner();  \n        inner.go();  \n    }  \n}\n\n위와 같이 value 라는 값이 중복으로 있을 때는 위와 같이 접근 가능하며 결과값은 아래와 같다.\n\nvalue = 3\nthis.value = 2\nShadowingMain.value = 1\n\n지역 클래스\n\n지역 클래스는 내부 클래스의 종류 중 하나로서 내부 클래스의 특성을 그대로 따른다\n지역 클래스는 지역 변수와 같이 코드 블럭 안에서 정의된다.\n\n특징\n\n지역 변수처럼 코드 블럭 안에 클래스 선언\n지연 변수에 접근 가능\n지역 클래스가 접근하는 지역 변수는 중간에 값이 변하면 안된다. 그러므로 final 로 선언하거나 사실상 final (한번 선언후 값을 변경하지 않는) 이여야 한다.\n\n익명 클래스\n\n익명 클래스 또한 내부 클래스의 종유 중 하나로서 내부 클래스의 특성을 따른다.\n익명 클래스는 선언과 생성을 하는 지역 클래스와 달리 선언과 생성을 한번에 하는 것이 특징이다.\n\nPrinter printer = new Printer(){\n\t//body\n}\npublic class AnonymousOuter {\n\tprivate int outInstanceVar = 3;\n\tpublic void process(int paramVar) {\n\t\tint localVar = 1;\n\t\t//익명클래스\n\t\tPrinter printer = new Printer() {\n\t\t\tint value = 0;\n\t\t\t@Override\n\t\t\tpublic void print() {\n\t\t\t\t\tSystem.out.println(&quot;value=&quot; + value);\n\t\t\t\t\tSystem.out.println(&quot;localVar=&quot; + localVar); \n\t\t\t\t\tSystem.out.println(&quot;paramVar=&quot; + paramVar);\n\t\t\t\t\tSystem.out.println(&quot;outInstanceVar=&quot; + outInstanceVar);\n\t\t\t}\n\t\t};\n\t\tprinter.print();\n\t\tSystem.out.println(&quot;printer.class=&quot; + printer.getClass());\n\t}\n\tpublic static void main(String[] args) {\n\t\tAnonymousOuter main = new AnonymousOuter();\n\t\tmain.process(2);\n\t}\n}\n특징\n\n익명 클래스는 이름 없는 지역 클래스를 선언하면서 동시에 생성.\n익명 클래스는 부모 클래스를 상속 받거나, 또는 인터페이스를 구현해야 한다.\n익명 클래스는 말 그대로 이름이 없다. 이름을 가지지 않으므로, 생성자를 가질 수 없다.\n"},"공부-정리/자바-중급/11.-예외-처리":{"slug":"공부-정리/자바-중급/11.-예외-처리","filePath":"공부 정리/자바 중급/11. 예외 처리.md","title":"11. 예외 처리","links":[],"tags":["JavaMid"],"content":"필요한 이유\n\n프로그램 실행 중 발생할 수 있는 예상치 못한 상황을 별도로 처리하여 프로그램의 안정성과 신뢰성을 높일 수 있다.\n\n예외 계층\n\n\nObject : 예외도 객체 이므로 객체의 최상위 클래스인 Objeect 클래스를 상속 받는다.\nThrowable : 최상위 예외이다. 이 객체를 예외 처리하면 Error 도 예외 처리 해버리기 때문에 Throwable 은 예외처리하면 안된다.\nError : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구가 불가능한 시스템 예외이므로 이 예외를 잡으려고 해서는 안된다.\nException : 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외로서 RuntimeException 을 제외하고는 체크 예외 이다.\nRuntimeException : 컴파일러가 체크 하지 않는 언체크 예외로서 그자식까지 모두 언체크 예외이다. 런타임 예외 라고도 부른다.\n\n체크 예외, 언체크 예외\n\n체크 예외는 발생한 예외를 개발자가 명시적으로 처리해야 한다. 그렇지 않으면 컴파일 오류 발생\n\n장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 안전 장치 역할을 할 수있다.\n단점 : 모든 체크 예외를 반드시 잡거나 던져야하기 때문에 번거로운 일이 될 수 있다.\n\n\n언체크 예외는 개발자가 명시적으로 처리하지 않아도 된다.\n\n장점 : 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 체크 예외의 경우 처리할 수 없는 예외를 밖으로 던지려면 항상 throws 를 선언해야 하지만, 언체크 예외는 생략 가능하다.\n단점 : 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다.\n\n\n\n예외 처리 기본 규칙\n\n예외는 잡아서 처리하거나 밖으로 던져야 한다.\n예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리할 수 있다 (객체 이기 떄문)\n예외를 main() 밖으로 던지면 예외 로그를 출력하면서 시스템이 종료된다.\n\n키워드\npublic class NetworkServiceV2_5 {  \n  \n    public void sendMessage(String data){  \n        String address = &quot;excample.com&quot;;  \n        NetworkClientV2 client = new NetworkClientV2(address);  \n        client.initError(data); // 추가  \n  \n        try {  \n            //정상 흐름  \n            client.connect();  \n            client.send(data);  \n        } catch (NetworkClientExceptionV2 e) {  \n            //예외 흐름  \n            System.out.println(&quot;오류 코드: &quot; + e.getErrorCode()+&quot;, 오류 메시지: &quot;+e.getMessage());  \n        } finally {  \n            //반드시 호출해야 하는 마무리 흐름  \n            client.disconnect();  \n        }  \n    }  \n}\n\ntry : 정상 흐름\ncatch(Exception e) : Exception 자리에 캐치하고 싶은 예외 객체를 넣는다. 예외 흐름\nfinally : 정상 흐름이든, 예외 흐름이든, 심지어는 잡아낼 수 없는 예외가 터질지라도 반드시 호출되는 마무리 흐름이다\n"},"공부-정리/자바-중급/12.-Generic":{"slug":"공부-정리/자바-중급/12.-Generic","filePath":"공부 정리/자바 중급/12. Generic.md","title":"12. Generic","links":["공부-정리/자바-중급/04.-래퍼-클래스"],"tags":["JavaMid"],"content":"필요성\n\n타입 안정성 보장\n코드 중복 해결 가능\n\npublic class GenericBox&lt;T&gt; {    // 코드중복 제거  \n    private T value;  \n  \n    public T get() {  \n        return value;  \n    }  \n  \n    public void set(T value) {  \n        this.value = value;  \n    }  \n}\npublic class BoxMain3 {  \n    public static void main(String[] args) {  \n\t    //생성 시점에 T의 타입이 결정하므로 타입 안정성 보장\n        GenericBox&lt;Integer&gt; integerBox = new GenericBox&lt;Integer&gt;(); \n        integerBox.set(10);  \n//        integerBox.set(&quot;문자100&quot;); // Integer Type 만 허용, 컴파일 오류  \n        Integer integer = integerBox.get();  \n        System.out.println(&quot;integer = &quot; + integer);  \n  \n        GenericBox&lt;String&gt; stringBox = new GenericBox&lt;String&gt;();  \n        stringBox.set(&quot;hello&quot;);  \n          \n        String srt = stringBox.get();  \n        System.out.println(&quot;srt = &quot; + srt);  \n          \n        GenericBox&lt;Double&gt; doubleBox = new GenericBox&lt;Double&gt;();  \n        doubleBox.set(10.5);  \n        Double doubleValue = doubleBox.get();  \n        System.out.println(&quot;doubleValue = &quot; + doubleValue);  \n  \n        //타입 추론 : 생성하는 제네릭 타입 생략 가능  \n        GenericBox&lt;Integer&gt; integerBox2 = new GenericBox&lt;&gt;();  \n    }  \n}\n정의\n\n클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것\n제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.\n타입 매개변수 ( Type Parameter )\n\n제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.\nex) GenericBox&lt;T&gt; 에서 T를 타입 매개변수라 한다.\n\n\n타입 인자 ( Type Argument )\n\n제네릭 타입을 사용할 때 제공되는 실제 타입이다.\nex) GenericBox&lt;Integer&gt; 에서 Integer 를 타입 인자라 한다.\n타입 인자로는 기본형은 사용할 수 없고 래퍼 클래스만 사용 가능 하다.\n\n\n\n명명 관례\n키워드\n\nE - Element ( 컬렉션 요소 )\nK - Key ( 키 값 )\nN - Number ( 숫자 타입 )\nT - Type ( 임의의 타입 )\nV - Value ( 값 )\nR - Result ( 결과 타입 )\n\n여러 타입 선언\nclass Data&lt;K, V&gt;{}\n타입 매개변수 제한\npublic class AnimalHospitalV3&lt;T extends Animal&gt; {  \n    private T animal;  \n  \n    public void set(T animal) {  \n        this.animal = animal;  \n    }  \n  \n    public void checkUp(){  \n        System.out.println(&quot;동물 이름: &quot;+ animal.getName());  \n        System.out.println(&quot;동물 크기: &quot; + animal.getSize());  \n        animal.sound();  \n    }  \n    public T bigger(T target){  \n        return animal.getSize()&gt; target.getSize()? animal : target;  \n    }  \n}\n\n&lt;T extends Animal&gt;를 함으로써 타입 매개변수의 상한을 지정 할 수 있다.\n위의 코드에서는 타입 인자로 Animal과 그 자식만 받을 수 있도록 제한을 둘 수 있다.\n"},"공부-정리/자바-중급/13.-Collection---ArrayList":{"slug":"공부-정리/자바-중급/13.-Collection---ArrayList","filePath":"공부 정리/자바 중급/13. Collection - ArrayList.md","title":"13. Collection - ArrayList","links":["공부-정리/자바-중급/cf.-빅오(O)-표기법"],"tags":["JavaMid"],"content":"필요성\n\n배열은 기본적인 자료 구조이고 효율이 좋지만 배열을 생성하는 시점에 배열의 크기를 정해야 한다는 것과 데이터를 추가 할 때 불편하다는 단점이 있다.\n배열처럼 처음부터 정적으로 길이가 정해져 있는 것이 아닌 동적으로 길이를 늘리고 줄일 수 있는 자료 구조의 필요성으로 List가 사용 된다.\n\n특징\n\nArrayList 는 자료 구조가 List 일 뿐, 내부의 데이터는 배열에 보관하는 것이므로 아래와 같은 특징이 있다.\n\n마지막 데이터를 추가하거나 삭제할 때는 O(1)로 매우 빠르다\n중간에 데이터를 추가하거나 삭제하는 경우 O(n)으로 느리다.\n그러므로 데이터를 중간에 추가하거나 삭제, 변경할 때 사용하기 보다는 데이터를 순서대로 입력하고, 출력하는 경우에 가장 효율적이다.\n\n\n\nArrayList의 빅오\n\n데이터 추가\n\n마지막에 추가: O(1)\n앞, 중간에 추가: O(n)\n\n\n데이터 삭제\n\n마지막에 삭제: O(1)\n앞, 중간에 삭제 : O(n)\n\n\n인덱스 조회: O(1)\n데이터 검색: O(n)\n\n사용법\npublic class ArrayMain2 {  \n  \n    public static void main(String[] args) {  \n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  \n    }  \n}\n생성자\n\nnew ArrayList(): 기본 크기가 10인 배열 생성 (배열이 다 차면 크기만큼 사이즈 증가)\nnew ArrayList(index) : 기본크기가 index인 배열 생성 (배열이 다 차면 크기만큼 사이즈 증가)\n\n주요 메서드\n\nadd(value): 순서대로 끝에 value 값을 추가 배열 사이즈 초과 시 초기 설정 된 사이즈만큼 자동으로 사이즈가 증가한다.\nadd(index, value): index 자리에 value값을 추가해 준다\nget(index): 해당 index의 값을 반환\nset(index, value): 해당 index의 값을 value값으로 변경\nindexOf(value): value 값이 있는 첫번째 index 반환\nlastindexOf(value): value 값이 있는 마지막 index 반환\ncontains(value): value 값이 배열에 있는지 검색하여 true / false로 반환\nclear(): 모두 삭제\nisEmpty(): 비어있으면 true, 그렇지 않다면 false 반환\nsize(): 요소의 개수 반환\naddAll(arr) : arr 컬렉션의 모든 요소를 현재 리스트의 끝에 추가\naddAll(index, arr) : arr 컬렉션의 모든 요소를 index위치에 추가\nretainAll(arr) : arr 컬렉션 내의 요소를 제외하고 모두 제거\nremoveAll(arr): arr 컬렉션 내의 요소와 일치하는 모든 요소 제거\n"},"공부-정리/자바-중급/14.-Collection---LinkedList":{"slug":"공부-정리/자바-중급/14.-Collection---LinkedList","filePath":"공부 정리/자바 중급/14. Collection - LinkedList.md","title":"14. Collection - LinkedList","links":[],"tags":["JavaMid"],"content":"필요성\n\n배열 리스트의 단점을 극복하기 위해 LinkedList를 필요로 한다.\nArrayList의 단점\n\n필요한 배열의 크기를 미리 확보해야 한다. (메모리 낭비)\n중간에 데이터 추가하거나 삭제할 시 추가할 데이터의 공간 확보를 위해 기존데이터들을 한칸 씩 오른쪽으로 이동해야 하며, 삭제 시 왼쪽으로 한칸 씩 이동해야 한다.\n\n\n\n특징\n\nLinkedList 또한 순서가 있고, 중복을 허용하는 자료 구조인 List 를 기본 베이스로 아래와 같은 특징을 가진다\n\n인덱스를 통해 추가나 삭제할 위치를 O(n) 으로 느리게 찾지만, 찾은 이후에는 일부 노드의 참조값만 변경하면 되므로 O(1)로 빠르다.\n데이터를 앞쪽에 추가하는 경우 일부 노드의 참조만 변경하면 된다. O(1)\n데이터를 뒤쪽에 추가하는 경우 조회의 경우 노드를 마지막까지 순회해야하므로 O(n) 으로 느리지만, 추가의 경우 일부 노드의 참조만 변경하면 된다. O(1) 결과적으로는 O(n)의 성능을 제공한다.\n\n\n\n사용법\npublic class LinkedMain2 {  \n  \n    public static void main(String[] args) {  \n        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();  \n    }  \n}\n생성자\n\nnew LinkedList&lt;&gt;(): 비어있는 LinkedList() 생성\nnew LinkedList&lt;&gt;(arg): arg의 모든 요소를 포함하는 LinkedList() 생성\n\n주요 메서드\n\nadd() : 리스트의 끝에 요소를 추가\nadd(index, value) : index에 요소를 삽입\naddFirst() : 첫 번째에 요소를 추가\naddLast(): 마지막에 요소를 추가\nget(index): index의 요소를 반환\ngetFirst(): 첫 번째 요소 반환\ngetLast(): 마지막 요소 반환\nremove(index): index의 요소 제거\nremove(value): value 값 제거\nremoveFirst() : 첫 번째 요소 제거\nremoveLast() : 마지막 요소 제거\ncantains(value): value값이 존재하는지 확인\nisEmpty(): 리스트가 비어있는지 확인\nsize(): 리스트의 요소 개수 반환\nclear() : 모든 요소 제거\n"},"공부-정리/자바-중급/15.-Collection---List":{"slug":"공부-정리/자바-중급/15.-Collection---List","filePath":"공부 정리/자바 중급/15. Collection - List.md","title":"15. Collection - List","links":[],"tags":["JavaMid"],"content":""},"공부-정리/자바-중급/cf.-메서드-체이닝":{"slug":"공부-정리/자바-중급/cf.-메서드-체이닝","filePath":"공부 정리/자바 중급/cf. 메서드 체이닝.md","title":"cf. 메서드 체이닝","links":[],"tags":["JavaMid"],"content":"\n객체가 자신을 반환하여 연속적으로 메서드를 호출할 수 있도록 설계된 방식\n\npublic class ValueAdder {  \n  \n    private int value;  \n  \n    public ValueAdder add(int addValue) {  \n        value += addValue;  \n        return this;  \n    }  \n  \n    public int getValue() {  \n        return value;  \n    }  \n}\n\n위의 코드에서 보면 add() 메서드가 매개변수로 받은 값을 더하여 객체 자식을 반환하는 것을 볼수 있다.\n\npublic class MethodChainingMain3 {  \n  \n    public static void main(String[] args) {  \n        ValueAdder adder = new ValueAdder();  \n        int result = adder.add(1).add(2).add(3).getValue();  //메서드 체이닝\n        System.out.println(&quot;result = &quot; + result);  \n    }  \n}\n\n위의 코드를 활용하면 메서드 체이닝 기법을 사용할 수 있다.\n"},"공부-정리/자바-중급/cf.-빅오(O)-표기법":{"slug":"공부-정리/자바-중급/cf.-빅오(O)-표기법","filePath":"공부 정리/자바 중급/cf. 빅오(O) 표기법.md","title":"cf. 빅오(O) 표기법","links":[],"tags":["JavaMid"],"content":"정의\n\n알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식\n알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 표시\n데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이 중요\n\n예시\n\n\nO(1) - 상수 시간 : 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정\nO(n) - 선형 시간 : 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가\nO(n^2) - 제곱 시간 : 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가\nO(log n) - 로그 시간 : 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가\nO(n log n) - 선형 로그 시간\n"},"공부-정리/자바-중급/자바-중급":{"slug":"공부-정리/자바-중급/자바-중급","filePath":"공부 정리/자바 중급/자바 중급.md","title":"자바 중급","links":["공부-정리/자바-중급/00.-java.lang-패키지","공부-정리/자바-중급/01.-Object-클래스","공부-정리/자바-중급/02.-불변-객체","공부-정리/자바-중급/03.-String-클래스","공부-정리/자바-중급/04.-래퍼-클래스","공부-정리/자바-중급/05.-Class-클래스","공부-정리/자바-중급/06.-System-클래스","공부-정리/자바-중급/07.-Math,-Random-클래스","공부-정리/자바-중급/08.-Enum-Type","공부-정리/자바-중급/09.-날짜와-시간","공부-정리/자바-중급/10.-중첩-클래스,-내부-클래스","공부-정리/자바-중급/11.-예외-처리","공부-정리/자바-중급/12.-Generic","공부-정리/자바-중급/13.-Collection---ArrayList","공부-정리/자바-중급/14.-Collection---LinkedList","공부-정리/자바-중급/15.-Collection---List","공부-정리/자바-중급/cf.-메서드-체이닝","공부-정리/자바-중급/cf.-빅오(O)-표기법"],"tags":["JavaStudy"],"content":"\n00. java.lang 패키지\n01. Object 클래스\n02. 불변 객체\n03. String 클래스\n04. 래퍼 클래스\n05. Class 클래스\n06. System 클래스\n07. Math, Random 클래스\n08. Enum Type\n09. 날짜와 시간\n10. 중첩 클래스, 내부 클래스\n11. 예외 처리\n12. Generic\n13. Collection - ArrayList\n14. Collection - LinkedList\n15. Collection - List\ncf. 메서드 체이닝\ncf. 빅오(O) 표기법\n"},"공부-정리/투두등장/CORS":{"slug":"공부-정리/투두등장/CORS","filePath":"공부 정리/투두등장/CORS.md","title":"CORS","links":[],"tags":["PJTStudyTodo"],"content":"CORS 란?\n\nCross-Origin Resource Sharing 의 약자로 다른 도메인 간의 리소스 요청을 허용하거나 차단하는 보안 정책이다.\n웹 브라우저는 기본적으로 동일 출처 정책 (Same-Origin Policy)을 적용해서 다른 도메인에서 온 요청을 차단한다. 그래서 API 서버와 프론트엔드가 다른 도메인에서 운영되는 경우, CORS를 설정해서 이를 허용해야 한다.\n\nSpringboot에 적용\n1. CorsConfig.java\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;) // 모든 요청에 대해 CORS 허용\n                .allowedOrigins(&quot;http://localhost:3000&quot;) // 허용할 도메인\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;) // 허용할 HTTP 메서드\n                .allowedHeaders(&quot;*&quot;); // 모든 헤더 허용\n    }\n}\n \n2. WebSecurityConfig.java\n@Configurable  \n@EnableWebSecurity  \n@RequiredArgsConstructor  \npublic class WebSecurityConfig {  \n  \n    private final JwtAuthenticationFilter jwtAuthenticationFilter;  \n  \n    @Bean  \n    protected SecurityFilterChain configure(HttpSecurity httpSecurity) throws Exception{  \n        httpSecurity  \n                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource())) // CORS 설정 적용 \n                .csrf(csrf -&gt; csrf.disable()) // CSRF 보호 비활성화 (필요한 경우)\n                .httpBasic(AbstractHttpConfigurer::disable)  \n                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))  \n                .authorizeHttpRequests(auth -&gt; auth  \n                .requestMatchers(&quot;/&quot;, &quot;/api/v1/auth/**&quot;, &quot;/api/v1/search/**&quot;).permitAll()  \n                .requestMatchers(HttpMethod.GET, &quot;/api/v1/board/**&quot;).permitAll()  \n                .anyRequest().authenticated()  \n                ).exceptionHandling(handler -&gt; handler.authenticationEntryPoint(new FailedAuthenticationEntryPoint()));  \n  \n        httpSecurity.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);  \n  \n        return httpSecurity.build();  \n    }  \n}  \n \n\t@Bean \n\tpublic CorsConfigurationSource corsConfigurationSource() { \n\t\tCorsConfiguration configuration = new CorsConfiguration();\n\t\tconfiguration.setAllowedOrigins(List.of(&quot;http://localhost:3000&quot;)); // 허용할 도메인 \n\t\tconfiguration.setAllowedMethods(List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)); \n\t\tconfiguration.setAllowedHeaders(List.of(&quot;*&quot;)); \n\t\tconfiguration.setAllowCredentials(true); // 인증 정보 허용 \n\t\tUrlBasedCorsConfigurationSource source = new \n\t\tUrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, configuration); \n\t\treturn source; \n\t}\n  \nclass FailedAuthenticationEntryPoint implements AuthenticationEntryPoint {  \n  \n    @Override  \n    public void commence(HttpServletRequest request, HttpServletResponse response,  \n                         AuthenticationException authException) throws IOException, ServletException {  \n  \n        response.setContentType(&quot;application/json&quot;);  \n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);  \n        response.getWriter().write(&quot;{\\&quot;FORBIDDEN ERROR\\&quot;}&quot;);  \n    }  \n}\n\n만약 CORS 설정을 직접 설정하지 않고 기본 설정을 사용하고 싶다면 http.cors(Customizer.withDefaults()) 하면 된다.\n"},"공부-정리/투두등장/DTO와-Entity-차이":{"slug":"공부-정리/투두등장/DTO와-Entity-차이","filePath":"공부 정리/투두등장/DTO와 Entity 차이.md","title":"DTO와 Entity 차이","links":[],"tags":["PJTStudyTodo"],"content":"Entity\n\nJPA에서 관리하는 객체로, 데이터베이스 테이블과 직접 연결 된다.\nDB를 변경하면 Entity도 변경된다.\n비지니스 로직도 포함 될 수 있다.\n@Entity를 사용하여 JPA가 관리하도록 설정\nDB 테이블의 모든 데이터가 포함되어야 한다.\n\nDTO\n\n클라이언트와 데이터를 주고받기 위한 객체\nDB와 직접 매핑되어있지 않다.\n필요한 데이터만 포함하여 보안성 강화 및 성능 최적화가 가능하다\n\nDTO, Entity 비교\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n구분EntityDTO목적DB 테이블과 직접 매핑API 응답 최적화Spring JPA 관리 여부JPA 관리 객체JPA 관리 X보안 문제민감한 데이터 노출 위험불필요한 데이터 제외 가능API 변경 시 영향Entity 변경 시 API도 변경 됨API 응답을 독립적으로 유지 가능불필요한 데이터 포함 여부모든 필드 포함불필요한 데이터 제거 가능"},"공부-정리/투두등장/JWT":{"slug":"공부-정리/투두등장/JWT","filePath":"공부 정리/투두등장/JWT.md","title":"JWT","links":[],"tags":["PJTStudyTodo"],"content":"JWT 란?\n\nJWT는 “JSON Web Token”의 약자이다\n웹 어플리케이션에서 사용자 인증 및 정보 교환을 위해 사용되는 토큰 기반 인증 방법이다\n기본적으로 서명되었지만 암호화되지 않았기 떄문에, 공개되어서는 안될 정보가 포함되어야 할 경우 JWE (JSON Web Encrytion) 방식으로 암호화 하여야 한다.\n\n장점\n\nStateless 인증\n\n서버에서 클라이언트의 인증 정보를 저장할 필요 없이, 토큰 자체가 모든 정보를 포함\n\n\nSelf-Contained 구조\n\n토큰 안에 사용자 정보, 유효 기간, 권한 정보 등이 포함되어 별도의 DB 조회 없이 검증 가능\n\n\n유연한 확장성\n보안성\nCORS 문제 해결\n\n브라우저와 백엔드 간 쿠키 기반 인증과 달리, 헤더에 포함되어 전송되므로 CORS 이슈가 적음\n\n\n\n단점\n\nPayload 노출 가능성 O\n\nBASE64로 인코딩된 정보는 쉽게 디코딩 가능\n\n\n토큰 크기가 큰 문제\n만료 후 즉시 폐기가 어려운 문제\n서버에서 토큰 관리가 어려운 문제제\n\nJWT 구조\nxxxxxx.yyyyyy.zzzzzz\n\nHeader.Payload.Signature\n\n\nJWT는 Header, Payload, Signature 로 구성되어 있다.\n\n헤더 (Header)\n{ \n\t&quot;alg&quot;: &quot;HS256&quot;, \n\t&quot;typ&quot;: &quot;JWT&quot; \n}\n\nHeader는 두 가지 타입의 정보를 가지고 있다.\n\nalg : Signature 해싱 알고리즘\ntyp : 토큰의 타입\n\n\n\n정보 (Payload)\n{\n    &quot;iss&quot;: &quot;dnjscksdn98.com&quot;,\n    &quot;exp&quot;: &quot;1485270000000&quot;,\n    &quot;dnjscksdn98.com/jwt_claims/is_admin&quot;: true,\n    &quot;userId&quot;: &quot;dnjscksdn98&quot;,\n    &quot;username&quot;: &quot;alex&quot;\n}\n\nPayload에는 토큰에 담을 정보가 들어있다.\n이곳에 담는 정보의 조각을 클레임 (Claim) 이라고 부르고, Key/ Value 형식으로 이루어져 있다.\n클레임의 종류는 Registered claims, Public claims, Private claims 로 나뉜다.\n\n등록된 클레임 ( Registered claims )\n\n등록된 클레임들은 토큰에 대한 정보들을 담기위하여 이름이 이미 정해진 클레임들이다. 필수는 아니지만, 권장되어 진다.\n\niss : 토큰을 발급한 주체(서버 또는 시스템) 의 식별자\nsub : 토큰이 인증하는 주체 (사용자 또는 서비스)\naud : 토큰이 사용될 대상 시스템 또는 수신자\nexp : 토큰 만료 시간\nnbf : 토큰 활성 시작 시간\niat : 토큰 발급 시간\njti : 토큰 중복사용 방지를 위한 고유한 식별자\n\n\n\n\n공개 클레임 ( Public claims )\n\n다른 개발자나 서비스와의 충돌을 방지하기 위해 IANA JSON Web Token Claims Registry 에 등록된 클레임을 사용하여야 한다.\n공개 클레임에는 누구나 읽을 수 있는 정보가 포함되므로 공개되면 안되는 정보(비밀번호, 계좌 번호 등)는 포함하면 안된다.\n\n\n비공개 클레임 ( Rpivate claims )\n\n비공개 클레임은 개인이나 특정 조직에서 내부적으로 정의하는 클레임이다.\n\n\n\n\n\n서명 (Signature)\n\nSignature 는 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.\n위에서 만든 헤더(Header)와 정보(Payload)의 값을 각각 BASE64로 인코딩하고, 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 해싱하고, 이 값을 다시 BASE64로 인코딩하여 생성한다.\n\nSpringboot에 적용\n0. 의존성 주입 (gradle)\nimplementation &#039;io.jsonwebtoken:jjwt-api:0.12.6&#039;  \nruntimeOnly &#039;io.jsonwebtoken:jjwt-impl:0.12.6&#039;  \nruntimeOnly &#039;io.jsonwebtoken:jjwt-jackson:0.12.6&#039;\n1. JwtProvider.java\npublic class JwtProvider {  \n  \n    private SecretKey secretKey = Jwts.SIG.HS256.key().build();  \n  \n    //JWT 생성 메서드  \n    public String create(String email){  \n        Date expiredDate = Date.from(Instant.now().plus(1, ChronoUnit.HOURS)); //현재시간에서 1시간 추가  \n  \n        String jwt = Jwts.builder()  \n                .signWith(secretKey)        //암호화 알고리즘  \n                .subject(email)             //사용자 식별자 값  \n                .issuedAt(new Date())       //생성 시간  \n                .expiration(expiredDate)    //만료 시간  \n                .compact();                 //압축하여 객체 생성  \n  \n        return jwt;  \n    }  \n  \n    //JWT 검증 메서드  \n    public String validate(String jwt){  \n        Claims claims = null;  \n  \n        try{  \n            claims = Jwts.parser().verifyWith(secretKey)    //서명 검즘  \n                    .build()                                //빌드  \n                    .parseSignedClaims(jwt)                 //JWT 파싱  \n                    .getPayload();                          //Claims 추출  \n  \n        } catch (JwtException e){  \n            e.printStackTrace();  \n            return null;  \n        }  \n  \n        return claims.getSubject();  \n    }  \n}\n2. JwtAuthenticationFilter.java\n@Component  \n@RequiredArgsConstructor  \npublic class JwtAuthenticationFilter extends OncePerRequestFilter {  \n  \n    private final JwtProvider jwtProvider;  \n  \n    @Override  \n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)  \n            throws ServletException, IOException {  \n  \n        try{  \n            String token = parseBearerToken(request);  \n  \n            if(token == null){  \n                filterChain.doFilter(request, response);  \n                return;  \n            }  \n  \n            String email = jwtProvider.validate(token);  \n  \n            if(email == null){  \n                filterChain.doFilter(request, response);  \n                return;  \n            }  \n  \n            AbstractAuthenticationToken authenticationToken =  \n                    new UsernamePasswordAuthenticationToken(email, null, AuthorityUtils.NO_AUTHORITIES);  \n  \n            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); //인증요청에 대한 세부정보 구축  \n  \n            SecurityContext securityContext = SecurityContextHolder.createEmptyContext();  \n            securityContext.setAuthentication(authenticationToken);  \n  \n            SecurityContextHolder.setContext(securityContext);  \n        } catch (Exception e){  \n            e.printStackTrace();  \n        }  \n  \n        filterChain.doFilter(request, response);  \n  \n    }  \n  \n    private String parseBearerToken(HttpServletRequest request){  \n  \n        String authorization = request.getHeader(&quot;Authorization&quot;);  \n  \n        boolean hasAuthorization = StringUtils.hasText(authorization);  \n        if(!hasAuthorization)  \n            return null;  \n        boolean isBearer = authorization.startsWith(&quot;Bearer &quot;);  \n        if (!isBearer)  \n            return null;  \n  \n        return authorization.substring(7);  \n    }  \n}\n3. WebSecurityConfig.java\npublic class WebSecurityConfig {  \n  \n    private final JwtAuthenticationFilter jwtAuthenticationFilter;  \n  \n    @Bean  \n    protected SecurityFilterChain configure(HttpSecurity httpSecurity) throws Exception{  \n        httpSecurity.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);  \n  \n        return httpSecurity.build();  \n    }  \n}"},"공부-정리/투두등장/Lombok-어노테이션":{"slug":"공부-정리/투두등장/Lombok-어노테이션","filePath":"공부 정리/투두등장/Lombok 어노테이션.md","title":"Lombok 어노테이션","links":[],"tags":["PJTStudyTodo"],"content":"Lombok 이란?\n\nJava 코드에서 반복적인 코드를 줄이는 라이브러리이다.\n\n장점\n\n코드 간결화 : getter/ setter 및 생성자 등을 자동 생성하여 코드가 간결해짐\n가독성 향상: 핵심 로직에 집중할 수 있도록 불필요한 코드 제거\n생산성 향상: 직접 작성해야 할 코드 양이 줄어들어 개발 속도 증가.\n일관성 유지: 자동 생성된 메서드가 동일한 패턴을 따르므르 유지보수 용이\n"},"공부-정리/투두등장/투두등장":{"slug":"공부-정리/투두등장/투두등장","filePath":"공부 정리/투두등장/투두등장.md","title":"투두등장","links":["공부-정리/투두등장/CORS","공부-정리/투두등장/DTO와-Entity-차이","공부-정리/투두등장/JWT","공부-정리/투두등장/Lombok-어노테이션"],"tags":["PJTStudy"],"content":"\nCORS\nDTO와 Entity 차이\nJWT\nLombok 어노테이션\n"},"프로젝트-별-Issue/기농이네/Backend/Backend":{"slug":"프로젝트-별-Issue/기농이네/Backend/Backend","filePath":"프로젝트 별 Issue/기농이네/Backend/Backend.md","title":"Backend","links":["프로젝트-별-Issue/기농이네/Backend/note/Auto-Increment로-생성된-id-재사용","tags/GinongIssueBack","tags/Java","tags/sql","tags/db","프로젝트-별-Issue/기농이네/Backend/note/Mapper-파일-맵핑-에러","tags/mybatis","프로젝트-별-Issue/기농이네/Backend/note/reg페이지-post요청-시-403-에러","tags/html","tags/Spring","tags/Security"],"tags":["GinongIssue","GinongIssueBack","Java","sql","db","mybatis","html","Spring","Security"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록키워드Auto Increment로 생성된 id 재사용GinongIssueBackJavasqldbMapper 파일 맵핑 에러GinongIssueBackJavamybatisreg페이지 post요청 시 403 에러GinongIssueBackJavahtmlSpringSecurity"},"프로젝트-별-Issue/기농이네/Backend/note/Auto-Increment로-생성된-id-재사용":{"slug":"프로젝트-별-Issue/기농이네/Backend/note/Auto-Increment로-생성된-id-재사용","filePath":"프로젝트 별 Issue/기농이네/Backend/note/Auto Increment로 생성된 id 재사용.md","title":"Auto Increment로 생성된 id 재사용","links":[],"tags":["GinongIssueBack","Java","sql","db"],"content":"admin/product/reg 페이지 작성 중 post요청으로 페이지에 값을 받은 후 Product테이블에 상품을 등록하고 이 Product 테이블에 Auto increment 로 생성된 id값을 Stock 에 product_id를 FK로 등록해야 하는데 자동으로 생성되는 값이라 방법을 찾아 봄\n\n\n\n&lt;insert id=&quot;save&quot; parameterType=&quot;Product&quot;&gt;  \n    INSERT INTO PRODUCT(  \n       name, price, quantity, weight, thumbnail_name, thumbnail_path,   \n       exp, `desc`, state, category_id, storage_type_id, admin_id,   \n       quantity_category_id, weight_category_id)   \n    VALUES(  \n       #{name}, #{price}, #{quantity}, #{weight}, #{thumbnailName}, #{thumbnailPath},  \n       #{exp}, #{desc}, #{state}, #{categoryId}, #{storageTypeId}, #{adminId},  \n       #{quantityCategoryId}, #{weightCategoryId} )  \n  &lt;/insert&gt;\n입력 할때 Auto increment 인 상품의 id를 기입하지 않았고 그렇기 때문에 insert 할때 id값이 들어가 있지도 않음. 하지만 상품등록 시 입력한 재고, 수확일자를 재고 테이블에 등록하기 위해서는 상품의 id가 FK로 필요하기 때문에 다시 받아와야 한다.\n//mapper\n&lt;insert id=&quot;save&quot; parameterType=&quot;Product&quot; \nuseGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;  //추가한 부분, id값을 Serviceimp로 보내줌  \n    INSERT INTO PRODUCT(  \n       name, price, quantity, weight, thumbnail_name, thumbnail_path,   \n       exp, `desc`, state, category_id, storage_type_id, admin_id,   \n       quantity_category_id, weight_category_id)   \n    VALUES(  \n       #{name}, #{price}, #{quantity}, #{weight}, #{thumbnailName}, #{thumbnailPath},  \n       #{exp}, #{desc}, #{state}, #{categoryId}, #{storageTypeId}, #{adminId},  \n       #{quantityCategoryId}, #{weightCategoryId} )  \n  &lt;/insert&gt;\n위의 방법으로 Service에 id값을 넘겨 받아 재고 등록까지 되게 하였음.\n다른 예제)\n//Mapper                                &lt;---------------------------------------&gt;\n&lt;insert id=&quot;save&quot; parameterType=&quot;Order&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;\n    insert into `ORDER`(`DATE`, `TYPE`, PRICE, QUANTITY, DETAIL_ID, MEMBER_ID, PRODUCT_ID, LOCATION_ID)  \n    VALUES(  \n    current_timestamp()  \n    ,#{type}  \n    ,#{price}  \n    ,#{quantity}  \n    ,#{detailId}  \n    ,#{memberId}  \n    ,#{productId}  \n    ,#{locationId})  \n&lt;/insert&gt;\n \n//useGeneratedKeys=&quot;true&quot;: 이 설정은 데이터베이스가 자동으로 생성한 키를 사용하여 키 값\n//을 생성하도록 지시\n//keyProperty=&quot;id&quot;: 이 설정은 자동으로 생성된 키 값을 저장할 Java 객체의 속성을 지정\n//ServiceImp\n \n@Override  \npublic long addOrder(Order order) {  \n    repository.save(order);  \n  \n    //Auto increment id값 return으로 Controller로 보내기  \n    return order.getId();  \n  \n}\n//Controller\n \nlong orderId = service.addOrder(order); //auto increment order id 값\n "},"프로젝트-별-Issue/기농이네/Backend/note/Mapper-파일-맵핑-에러":{"slug":"프로젝트-별-Issue/기농이네/Backend/note/Mapper-파일-맵핑-에러","filePath":"프로젝트 별 Issue/기농이네/Backend/note/Mapper 파일 맵핑 에러.md","title":"Mapper 파일 맵핑 에러","links":[],"tags":["GinongIssueBack","Java","mybatis"],"content":"\n잘되던 detail 페이지가 뭐 건드리지도 않았는데 갑자기 매퍼파일에서 맵핑이 되지않아 에러가 뜸.\nimport가 잘못됐나 확인해보았지만 이상이 없어고.. 해결법은 찾았지만 그 이유가 너무나 허무했다.\n\n조장님이 Mapper파일이 너무 많아 /mappers 안에 있던 mapper파일들을 그 기능에 맞게 분류 해두셨는데\nmybatis:  \n  configuration:  \n    map-underscore-to-camel-case: true  \n  mapper-locations: mappers/*Mapper.xml  \n  type-aliases-package: kr.co.ginong.web.entity.*\n\n우리의 mybatis 설정은 mappers 상위에 mapper파일들을 지정해뒀는데 중간에 기능별 경로가 생겨 읽어 줄수 없었던것이다…\nmybatis:  \n  configuration:  \n    map-underscore-to-camel-case: true  \n  mapper-locations: mappers/*/*Mapper.xml  \n  type-aliases-package: kr.co.ginong.web.entity.*\n\n\n중간 경로를 추가해줘서 해결"},"프로젝트-별-Issue/기농이네/Backend/note/reg페이지-post요청-시-403-에러":{"slug":"프로젝트-별-Issue/기농이네/Backend/note/reg페이지-post요청-시-403-에러","filePath":"프로젝트 별 Issue/기농이네/Backend/note/reg페이지 post요청 시 403 에러.md","title":"reg페이지 post요청 시 403 에러","links":[],"tags":["GinongIssueBack","Java","html","Spring","Security"],"content":"\npost요청으로 값이 전부 올바르게 들어갔음에도 403 에러가 발생했음.\n\nChat GPT 에게 물어봐서 차례대로 문제해결 해보기로 했다.\npackage kr.co.ginong.web.config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;  \nimport org.springframework.security.web.SecurityFilterChain;  \n  \n@Configuration  \npublic class WebSecurityConfig {  \n    @Bean  \n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {  \n  \n       http   \n       .csrf(csrf-&gt;csrf.disable()) \n       .authorizeHttpRequests((requests) -&gt; requests  \n       .anyRequest().permitAll()  \n       );  \n  \n       return http.build();  \n    }  \n}\n개발중이라 권한은 모두 풀어놓은 상태라 문제가 없어보인다. 1,2 번 제외하고 3번으로 넘어가자.\n\n아직 csrf는 안 배웠고 따로 설정을 하지 않아서 post요청에 csrf토큰이 포함되지 않아 에러가 난거 같아 Rland 실습 중에 임의로 세팅 해놓은 코드를 확인해보았다.\nhttp  \n.csrf(csrf-&gt;csrf.disable())  \n       .authorizeHttpRequests((requests) -&gt; requests  \n    .requestMatchers(&quot;/member/**&quot;).hasAnyRole(&quot;MEMBER&quot;,&quot;ADMIN&quot;)  \n    .requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)  \n    .anyRequest().permitAll()  \n       )\n.csrf(csrf→csrf.disable())  로 개발중에 post요청 시 csrf토큰 필요 유무를 disable로 한 후 다시 post요청하니 정상 작동하였다\npackage kr.co.ginong.web.config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;  \nimport org.springframework.security.web.SecurityFilterChain;  \n  \n@Configuration  \npublic class WebSecurityConfig {  \n    @Bean  \n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {  \n  \n       http   \n       .csrf(csrf-&gt;csrf.disable()) \n       .authorizeHttpRequests((requests) -&gt; requests  \n       .anyRequest().permitAll()  \n       );  \n  \n       return http.build();  \n    }  \n}\n최종코드"},"프로젝트-별-Issue/기농이네/Frontend/Frontend":{"slug":"프로젝트-별-Issue/기농이네/Frontend/Frontend","filePath":"프로젝트 별 Issue/기농이네/Frontend/Frontend.md","title":"Frontend","links":["프로젝트-별-Issue/기농이네/Frontend/note/JavaScript-정규표현식-사용","tags/GinongIssueFront","tags/Javascript","tags/정규식","프로젝트-별-Issue/기농이네/Frontend/note/Selector-옵션-hover-시-색이-파란색으로-고정","tags/html","tags/css"],"tags":["GinongIssue","GinongIssueFront","Javascript","정규식","html","css"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록키워드JavaScript 정규표현식 사용GinongIssueFrontJavascript정규식Selector 옵션 hover 시 색이 파란색으로 고정GinongIssueFronthtmlJavascriptcss"},"프로젝트-별-Issue/기농이네/Frontend/note/JavaScript-정규표현식-사용":{"slug":"프로젝트-별-Issue/기농이네/Frontend/note/JavaScript-정규표현식-사용","filePath":"프로젝트 별 Issue/기농이네/Frontend/note/JavaScript 정규표현식 사용.md","title":"JavaScript 정규표현식 사용","links":[],"tags":["GinongIssueFront","Javascript","정규식"],"content":"이메일 인증 구현 중 옳바른 이메일 형식이 아닐 시 alert로 유효한 이메일이 아니라는 알람을 띄우기 위해 작업하기 위해 정규표현식을 사용하여 구현하려 아래와 같은 코드를 짬.\nlet email = emailSend.querySelector(&#039;input[name=&quot;mail&quot;]&#039;).value;  \n//이메일 주소 유효성 검증  \nif(email!== /^[a-zA-Z0-9]+@[a-zA-Z0-9]+$/){  \n    alert(&quot;유효한 이메일 형식이 아닙니다.&quot;);  \n}  \nelse\n{\n...유효한 이메일 일시 검증번호를 사용자 이메일로 보내는 로직\n}\n@를 뺀 이메일 주소를 넣었을 시 생각대로 alert가 떠줬지만 @을 입력한 옳바른 주소를 입력했음에도 alert가 떠서 gpt를 통해 물어보니 아래와 같은 코드를 추천해 주었다.\nlet email = emailSend.querySelector(&#039;input[name=&quot;mail&quot;]&#039;).value; \n// 이메일 주소 유효성 검증 \nif (!/^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]+$/.test(email)) { \n\talert(&quot;유효한 이메일 형식이 아닙니다.&quot;); \n}\n!== 가 아닌 test 메소드를 이용해 비교를 하는 것을 보고 무엇인지 알아보기 위해 mdn을 참고하였다.\n\nconst str = &quot;hello world!&quot;;\nconst result = /^hello/.test(str);\n \nconsole.log(result); // true\n위와 같이 // 안에 정규표현식을 담고 비교해야 정상적으로 비교 가능하다."},"프로젝트-별-Issue/기농이네/Frontend/note/Selector-옵션-hover-시-색이-파란색으로-고정":{"slug":"프로젝트-별-Issue/기농이네/Frontend/note/Selector-옵션-hover-시-색이-파란색으로-고정","filePath":"프로젝트 별 Issue/기농이네/Frontend/note/Selector 옵션 hover 시 색이 파란색으로 고정.md","title":"Selector 옵션 hover 시 색이 파란색으로 고정","links":[],"tags":["GinongIssueFront","html","Javascript","css"],"content":"옵션을 선택하여 선택한 데이터를 post요청에 담아 controller로 보내기 위해 selector 구문을 사용하기로 했지만 옵션 hover 시 파란색으로 고정되어 있음.\n&lt;div class=&quot;n-select&quot;&gt; \n\t&lt;select name=&quot;pets&quot; id=&quot;pet-select&quot;&gt; \n\t\t&lt;option value=&quot;&quot;&gt;Please choose an option&lt;/option&gt; \n\t\t&lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt; \n\t\t&lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt; \n\t\t&lt;option value=&quot;hamster&quot;&gt;Hamster&lt;/option&gt; \n\t&lt;/select&gt; \n&lt;/div&gt;\n일반적인 selector로 손쉽게 사용 가능하지만 hover시 파란색인 것을 수정 할 수 없었음.\n//css \noption:hover {\n  background-color: red;\n}\n \n해당 구문을 css에 사용 시 간단하게 색 지정이 가능하나 현재는 파이썬에서만 작동하고 크롬에서 작동하지 않아 여러 방법을 찾아보게 됨.\n//html\n&lt;div class=&quot;custom-dropdown&quot;&gt;  \n    &lt;div class=&quot;selected-option deco deco-pos:right icon:RT deco-size:1 deco-color:main-6&quot; id=&quot;selectedOptionCategory&quot;&gt;카테고리 선택&lt;/div&gt;  \n    &lt;ul class=&quot;options&quot;&gt;  \n        &lt;li class=&quot;option&quot; data-value=&quot;1&quot;&gt;과채&lt;/li&gt;  \n        &lt;li class=&quot;option&quot; data-value=&quot;2&quot;&gt;앙념&lt;/li&gt;  \n        &lt;li class=&quot;option&quot; data-value=&quot;3&quot;&gt;가공식품&lt;/li&gt;  \n    &lt;/ul&gt;  \n&lt;/div&gt;\n&lt;input type=&quot;hidden&quot; id=&quot;selectedCategory&quot; name=&quot;categoryId&quot; value=&quot;1&quot;&gt;\n//JavaScript\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() {  \n    var selectedOption = document.getElementById(&#039;selectedOptionCategory&#039;);  \n    var options = document.querySelectorAll(&#039;.option&#039;);  \n    var selectedCategoryInput = document.getElementById(&#039;selectedCategory&#039;);  \n  \n    selectedOption.addEventListener(&#039;click&#039;, function() {  \n        var optionList = this.nextElementSibling;  \n        optionList.style.display = (optionList.style.display === &#039;block&#039;) ? &#039;none&#039; : &#039;block&#039;;  \n    });  \n  \n    options.forEach(function(option) {  \n        option.addEventListener(&#039;click&#039;, function() {  \n            var selectedValueCategory = this.getAttribute(&#039;data-value&#039;);  \n            selectedOption.textContent = this.textContent;  \n            selectedCategoryInput.value = selectedValueCategory; // hidden input에 선택된 값을 설정  \n            this.parentNode.style.display = &#039;none&#039;;  \n        });  \n    });  \n  \n    // 드롭다운 닫기  \n    document.addEventListener(&#039;click&#039;, function(event) {  \n        if (!selectedOption.contains(event.target)) {  \n            options.forEach(function(option) {  \n                option.parentNode.style.display = &#039;none&#039;;  \n            });  \n        }  \n    });  \n});\n//css\n.custom-dropdown {  \n    position: relative;  \n    display: inline-block;  \n}  \n/*처음 클릭하는 곳 스타일링*/  \n.selected-option {  \n    background-color: #ffffff;  \n    padding: 8px 16px;  \n    border: 1px solid var(--color-main-5);  \n    border-radius: 5px;  \n    cursor: pointer;  \n    width: 250px;  \n    height : 40px;  \n    display: flex;  \n    align-items: center;  \n    justify-content: space-between;  \n}  \n/*메뉴 고르는곳 스타일링*/  \n.options {  \n    position: absolute;  \n    list-style-type: none;  \n    padding: 0;  \n    margin: 0;  \n    background-color: #ffffff;  \n    border: 1px solid var(--color-main-5);  \n    border-top: none;  \n    border-radius: 5px;  \n    display: none;  \n    width: 250px;  \n    align-items: center;  \n    justify-content: center;  \n    z-index: 1;  \n}  \n  \n.option {  \n    padding: 8px 16px;  \n    cursor: pointer;  \n}  \n  \n.option:hover {  \n    background-color: var(--color-base-2); /*버튼 마우스오버 시 색상 지정*/  \n}\n\n해당 구문 사용으로 hover시 색상을 바꾸게 되었음.또한 선택한 data-value 값이 post요청 시 controller로 name : data-value 값으로 잘 넘어가는 것을 확인 하였다.\n근데 hover 색상 하나 꾸며주자고 이렇게 긴 코드가 필요하다니… …빨리 option:hover가 크롬에도 적용되면 좋겠다.."},"프로젝트-별-Issue/기농이네/기농이네":{"slug":"프로젝트-별-Issue/기농이네/기농이네","filePath":"프로젝트 별 Issue/기농이네/기농이네.md","title":"기농이네","links":["프로젝트-별-Issue/기농이네/Frontend/Frontend","프로젝트-별-Issue/기농이네/Backend/Backend"],"tags":["Issue"],"content":"\nFrontend\nBackend\n"},"프로젝트-별-Issue/투두등장/Backend/Backend":{"slug":"프로젝트-별-Issue/투두등장/Backend/Backend","filePath":"프로젝트 별 Issue/투두등장/Backend/Backend.md","title":"Backend","links":["프로젝트-별-Issue/투두등장/Backend/note/Postman-POST-요청-401-에러","tags/TodoIssueBack","tags/anotation","tags/postman","tags/csrf","tags/401에러","프로젝트-별-Issue/투두등장/Backend/note/LocalDateTime,-OffsetDateTime","tags/날짜와시간"],"tags":["TodoIssue","TodoIssueBack","anotation","postman","csrf","401에러","날짜와시간"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록키워드Postman POST 요청 401 에러TodoIssueBackanotationpostmancsrf401에러LocalDateTime, OffsetDateTimeTodoIssueBack날짜와시간"},"프로젝트-별-Issue/투두등장/Backend/note/LocalDateTime,-OffsetDateTime":{"slug":"프로젝트-별-Issue/투두등장/Backend/note/LocalDateTime,-OffsetDateTime","filePath":"프로젝트 별 Issue/투두등장/Backend/note/LocalDateTime, OffsetDateTime.md","title":"LocalDateTime, OffsetDateTime","links":["공부-정리/자바-중급/09.-날짜와-시간"],"tags":["TodoIssueBack","날짜와시간"],"content":"문제 발생\n\n프론트에서 받은 시간과 DB에 저장되는 시간이 차이가 나기 시작하였다.\n\n해결 과정\n\n지금 진행하는 프로젝트에서는 날짜와 시간만 필요하므로 날짜와 시간을 둘 다 쓰는 LocalDateTime을 사용했지만 이는 UTC 기준으로 하면 시간대의 차이가 나버린다.\n시간대를 고려하지 않는 날짜 객체를 사용하지 말고 포함하는 객체인 OffsetDateTime 이나 ZoneDateTime 같은 것을 사용하여야 한다는 것을 알게 되었다.\n\n결론\n\n아직 실무에 들어가지 않았지만 시간대를 고려하는 것을 필수라는 생각이 든다. 그러므로 날짜와 시간 객체를 사용하려면 OffsetDateTime 이나 ZoneDateTime을 사용해야 겠다는 생각을 하였다.\n"},"프로젝트-별-Issue/투두등장/Backend/note/Postman-POST-요청-401-에러":{"slug":"프로젝트-별-Issue/투두등장/Backend/note/Postman-POST-요청-401-에러","filePath":"프로젝트 별 Issue/투두등장/Backend/note/Postman POST 요청 401 에러.md","title":"Postman POST 요청 401 에러","links":[],"tags":["TodoIssueBack","anotation","postman","csrf","401에러"],"content":"문제 발생\n\n회원가입을 구현하는 과정에서 백단을 구현 후 postman을 이용하여 post 요청을 하려는데 401 에러가 터졌다.\n\n\n해결 과정\n\n\nController 에는 request 값이 들어오나 확인하기 위해 출력문구를 넣어보았으나 출력 문구가 나오지 않는 걸로보아 그전 Filter에서 막혀 Controller 까지 오지도 못하는 것 같았다.\n\n\n401 에러는 인증관련 문제이므로 어떤 문제점이 있는지 알기 위해 application.propoerties 에 logging.level.org.springframework.security = DEBUG 을 추가하여 어떤 문제점이 있는지 확인해 보았다.\n\n\n\ncsrf 관련 에러가 터졌는데 이미 disable 해놨는데 왜 이런 문제가 생겼는지 이해가 안갔다.\n\n\n@Bean  \nprotected SecurityFilterChain configure(HttpSecurity httpSecurity) throws Exception{  \n    httpSecurity  \n            .cors(Customizer.withDefaults())            //기본 cors설정 사용  \n            .csrf(AbstractHttpConfigurer::disable)  \n            .httpBasic(AbstractHttpConfigurer::disable)  \n            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))  \n            .authorizeHttpRequests(auth -&gt; auth  \n            .requestMatchers(&quot;/&quot;, &quot;/api/auth/**&quot;, &quot;/api/search/**&quot;).permitAll()  \n            .requestMatchers(HttpMethod.GET, &quot;/api/calendar/**&quot;).permitAll()  \n            .anyRequest().authenticated()  \n            ).exceptionHandling(handler -&gt; handler.authenticationEntryPoint(new FailedAuthenticationEntryPoint()));  \n  \n    httpSecurity.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);  \n  \n    return httpSecurity.build();  \n}\n결론\n\n@Configuration 어노테이션을 사용하여 Spring이 설정 클래스로 인식하게 했어야 했으나 @Configurable 어노테이션이 사용되어 있었다.. 자동완성으로 코딩하다가 이 부분을 놓친 것 같다.\n자동완성이 편리하긴 하지만 자동으로 되는 것들에 대해 내가 원하는 것이 맞는지 한번 더 확인하는 습관을 길러야겠다고 생각했다.\n"},"프로젝트-별-Issue/투두등장/Frontend/Frontend":{"slug":"프로젝트-별-Issue/투두등장/Frontend/Frontend","filePath":"프로젝트 별 Issue/투두등장/Frontend/Frontend.md","title":"Frontend","links":["프로젝트-별-Issue/투두등장/Frontend/note/Tailwindcss-프레임워크-적용-문제","tags/TodoIssueFront","tags/tailwind"],"tags":["TodoIssue","TodoIssueFront","tailwind"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n목록키워드Tailwindcss 프레임워크 적용 문제TodoIssueFronttailwind"},"프로젝트-별-Issue/투두등장/Frontend/note/Tailwindcss-프레임워크-적용-문제":{"slug":"프로젝트-별-Issue/투두등장/Frontend/note/Tailwindcss-프레임워크-적용-문제","filePath":"프로젝트 별 Issue/투두등장/Frontend/note/Tailwindcss 프레임워크 적용 문제.md","title":"Tailwindcss 프레임워크 적용 문제","links":[],"tags":["TodoIssueFront","tailwind"],"content":"\n이번 프로젝트는 Tailwind 사용해보기 위해 아래와 같이 명령어를 실행했다.\n\n# Tailwind 설치\nnpm install -D tailwindcss\n \n# 설정 파일 생성\nnpx tailwindcss init -p\n\n하지만 npx tailwindcss init -p  명령어 입력하니 ‘tailwind’은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다. 라는 오류 메시지와 함께 설정 파일이 생성되지 않았다.\nnpx tailwindcss init -p 이 명령어는 node_modules/.bin  경로에 있는 tailwindcss.cmd 파일을 실행하기 위함인데 해당 디렉토리에 가보니 tailwindcss.cmd 파일을 찾을 수 없었다.\n재설치도 해보고 GPT 도움도 받아보고 했지만 모두 해결할 수 없어 Tailwindcss 공홈에 들어가 보았고 4.0버전부터 적용 방법이 바뀌었다는걸 알게되었다.\n\n1. 설치\nnpm install tailwindcss @tailwindcss/vite\n\ntailwindcss install, vite가 아닌 다른 걸 사용한다면 tailwind 홈페이지 참조\n\n2. vite.config.ts 수정\nimport { defineConfig } from &#039;vite&#039;\nimport tailwindcss from &#039;@tailwindcss/vite&#039;\n \nexport default defineConfig({ \n\tplugins: [ \n\t\ttailwindcss(), \n\t],\n})\n\nvite.config.ts 의 코드를 위와 같이 수정\n\n3. CSS 파일에 import\n@import &quot;tailwindcss&quot;;\n\n엄한거 말고 공홈 레퍼런스를 확인해보도록 하자…\n"},"프로젝트-별-Issue/투두등장/투두등장":{"slug":"프로젝트-별-Issue/투두등장/투두등장","filePath":"프로젝트 별 Issue/투두등장/투두등장.md","title":"투두등장","links":["프로젝트-별-Issue/투두등장/Backend/Backend","프로젝트-별-Issue/투두등장/Frontend/Frontend"],"tags":["Issue"],"content":"\nBackend\nFrontend\n"},"프로젝트-별-Issue/편의점/Backend/Backend":{"slug":"프로젝트-별-Issue/편의점/Backend/Backend","filePath":"프로젝트 별 Issue/편의점/Backend/Backend.md","title":"Backend","links":[],"tags":["ConIssue"],"content":""},"프로젝트-별-Issue/편의점/편의점":{"slug":"프로젝트-별-Issue/편의점/편의점","filePath":"프로젝트 별 Issue/편의점/편의점.md","title":"편의점","links":["프로젝트-별-Issue/편의점/Backend/Backend"],"tags":["Issue"],"content":"\nBackend\n"},"프로젝트-별-Issue/프로젝트-별-Issue":{"slug":"프로젝트-별-Issue/프로젝트-별-Issue","filePath":"프로젝트 별 Issue/프로젝트 별 Issue.md","title":"프로젝트 별 Issue","links":["프로젝트-별-Issue/편의점/편의점","프로젝트-별-Issue/투두등장/투두등장","프로젝트-별-Issue/기농이네/기농이네"],"tags":["root"],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n목록내용편의점편의점 포스 기능 구현 팀 프로젝트투두등장일정 관리 및 할일 목록을 관리하는 웹 어플리케이션기농이네농산물 판매 플랫폼 구현 한팀 프로젝트"}}