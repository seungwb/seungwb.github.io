## ✅ 절차 지향 vs 객체 지향 프로그래밍

---

### 🔹 1. 절차 지향 프로그래밍 (Procedural Programming)

| 항목    | 내용                                    |
| ----- | ------------------------------------- |
| 핵심 관점 | **절차(순서)**와 **명령어의 흐름** 중심            |
| 설계 방식 | "무엇을 먼저 하고, 그다음엔 무엇을 할까?" 같은 실행 흐름 중심 |
| 특징    | 데이터와 함수(처리 로직)가 **분리**되어 있음           |
| 장점    | 단순한 문제에 적합, 흐름 제어가 직관적                |
| 단점    | 유지보수 어려움, 코드 중복, 확장성 떨어짐              |
| 대표 언어 | C, 초기의 BASIC 등                        |

---

### 🔹 2. 객체 지향 프로그래밍 (OOP: Object-Oriented Programming)

|항목|내용|
|---|---|
|핵심 관점|**객체 중심** – 데이터 + 행동을 묶은 단위|
|설계 방식|"어떤 객체가 어떤 역할을 맡고 어떻게 협력할까?"|
|특징|객체가 상태(state)와 행위(behavior)를 가짐|
|장점|**모듈화**, **재사용성**, **확장성**, **유지보수 용이**|
|단점|초기에 구조 설계가 복잡할 수 있음|
|대표 언어|Java, Python, C++, C#, Kotlin 등|

---

### 🔹 3. 두 패러다임의 핵심 차이

|비교 항목|절차 지향|객체 지향|
|---|---|---|
|중심 요소|**프로세스(절차)**|**객체와 메시지**|
|설계 관점|"어떻게 처리할 것인가?"|"무엇이 행동할 것인가?"|
|데이터 구조|데이터와 함수가 분리됨|객체 내부에 데이터와 메서드가 함께 있음|
|변경 유연성|구조 변경에 약함|구조 변경에 강함 (다형성, 캡슐화 등 덕분)|

---

### 객체 지향이 실무에서 중요한 이유

> **대규모 프로젝트는 수많은 개발자, 수많은 기능, 수많은 수정이 동반된다.**  
> 이 복잡성을 **잘게 쪼개고**, **유연하게 관리**하기 위해 객체 지향은 필수적이다.

#### 주요 이점

1. **재사용성** – 객체 단위로 재활용 가능
2. **모듈화** – 기능별로 코드 분리, 유지보수 쉬움
3. **확장성** – 새로운 기능 추가 시 기존 코드 수정 최소화
4. **유지보수** – 버그 수정이나 개선이 국소적으로 가능
5. **복잡도 관리** – 추상화를 통해 시스템 전체가 명확해짐

---

## ✅ 좋은 객체 지향 프로그래밍이란?

---

### 🔹 객체 지향의 핵심 개념

|개념|설명|
|---|---|
|**캡슐화(Encapsulation)**|데이터와 메서드를 하나로 묶고, 외부에서 직접 접근 못 하도록 제한 (`private`, `getter/setter`)|
|**상속(Inheritance)**|기존 클래스의 속성과 기능을 물려받아 새로운 클래스를 생성|
|**다형성(Polymorphism)**|하나의 인터페이스로 여러 구현체를 대체할 수 있는 능력|
|**추상화(Abstraction)**|복잡한 내부 구현은 숨기고, 필요한 인터페이스만 제공|
|**메시지 전달(Message Passing)**|객체 간 메시지(메서드 호출)를 통해 상호작용|

---

### 🔹 객체 지향 프로그래밍이란?

> 객체 간의 협력으로 동작하는 소프트웨어를 설계하고 개발하는 방식.  
> 하나의 커다란 명령어 흐름이 아닌, **객체들의 자율성과 관계**를 중심으로 시스템을 구성.

## ✅ 객체 지향 설계의 5대 원칙 — SOLID

> **SOLID**는 객체 지향 설계를 더욱 견고하고, 유연하고, 유지보수 가능하게 만드는 5가지 원칙의 집합이다.  
> Robert C. Martin(“Clean Code”의 저자)이 제안함.

---

### 🔹 1. **S** - 단일 책임 원칙 (Single Responsibility Principle, **SRP**)

- **정의**: 하나의 클래스는 **하나의 책임만 가져야 한다**
- **목표**: **변경 이유가 하나뿐인 클래스**를 만들 것
- ❌ 나쁜 예: `UserService`가 로그인, 회원가입, 이메일 전송, DB 처리까지 다 담당
- ✅ 좋은 예: `AuthService`, `MailService`, `UserRepository`로 분리

> 👉 클래스 하나가 여러 기능을 다 처리하면, **수정 시 다른 기능까지 깨질 위험이 커짐**

---

### 🔹 2. **O** - 개방-폐쇄 원칙 (Open/Closed Principle, **OCP**)

- **정의**: **확장에는 열려 있고, 변경에는 닫혀 있어야 한다**
- **목표**: 기능 추가는 쉽게 하되, 기존 코드 수정을 최소화
- ❌ 나쁜 예: 새로운 할인 정책이 생길 때마다 `DiscountService` 내부 코드 if-else 수정
- ✅ 좋은 예: `DiscountPolicy` 인터페이스를 만들고, 새로운 정책을 상속받아 구현

> 👉 새로운 기능은 **클래스를 추가**해서 구현하고, 기존 클래스는 **건드리지 말자**

---

### 🔹 3. **L** - 리스코프 치환 원칙 (Liskov Substitution Principle, **LSP**)

- **정의**: **자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다**
- **목표**: 상속받은 객체가 부모의 계약을 어기지 않도록
- ❌ 나쁜 예: `Bird`를 상속받은 `Penguin` 클래스에서 `fly()` 메서드를 던짐 (펭귄은 못 날아!)
- ✅ 좋은 예: `FlyingBird`와 `WalkingBird`를 구분한 뒤, 필요시 따로 상속

> 👉 부모 타입으로 자식을 썼을 때 **기대한 동작이 깨지면 LSP 위반**

---

### 🔹 4. **I** - 인터페이스 분리 원칙 (Interface Segregation Principle, **ISP**)

- **정의**: **클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 한다**
- **목표**: **작고 구체적인 인터페이스로 나누기**
- ❌ 나쁜 예: `Machine` 인터페이스에 `print()`, `scan()`, `fax()` 다 들어있음 → 프린터는 fax 기능 필요 없음
- ✅ 좋은 예: `Printable`, `Scannable`, `Faxable` 등으로 인터페이스를 나눔

> 👉 하나의 거대한 인터페이스보단 **역할별로 쪼개진 인터페이스가 더 유연함**

---

### 🔹 5. **D** - 의존 역전 원칙 (Dependency Inversion Principle, **DIP**)

- **정의**: **상위 모듈이 하위 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 한다**
- **목표**: 구현 클래스에 의존하지 말고 **인터페이스에 의존**
- ❌ 나쁜 예: `OrderService`가 `MysqlOrderRepository`에 직접 의존
- ✅ 좋은 예: `OrderRepository` 인터페이스에 의존 → 구현은 외부에서 주입

> 👉 DIP를 지키면 **의존성 주입(DI)**이 자연스럽게 따라오고, 테스트/확장성이 폭발적으로 올라감

---

## SOLID 요약 테이블

|원칙|이름|요약 핵심|결과|
|---|---|---|---|
|**S**|단일 책임|클래스는 하나의 이유로만 변경되어야|유지보수 쉬움|
|**O**|개방-폐쇄|확장에는 열려 있고, 변경엔 닫혀야|기능 확장 쉬움|
|**L**|리스코프 치환|자식은 부모를 대체할 수 있어야|다형성 안정성|
|**I**|인터페이스 분리|인터페이스는 작고 구체적으로|불필요한 의존 제거|
|**D**|의존 역전|구체 클래스 대신 추상화에 의존|DI 기반 유연성|