## ✅ 자바의 상속 (Inheritance)

> **[객체 지향 프로그래밍](<03. 절차 지향 프로그래밍, 객체 지향 프로그래밍.md>)(OOP)의 4대 특성 중 하나**


---

### 🔹 1. 상속이란?

> 기존 클래스의 **필드(변수)와 메서드(기능)** 를 **새로운 클래스에서 재사용**할 수 있도록 해주는 객체 지향의 핵심 개념

- `extends` 키워드를 사용
- **코드 재사용**, **유지보수 용이성**, **유연한 확장** 가능

---

### 🔹 2. 상속 구조의 기본 구성

|용어|설명|
|---|---|
|**부모 클래스 (Super Class)**|자식 클래스에게 상속되는 기능과 상태를 제공|
|**자식 클래스 (Sub Class)**|부모 클래스의 기능을 상속받고, 추가적으로 확장 가능|

```java
public class Car {
    public void move() {
        System.out.println("차를 이동합니다.");
    }
}

public class ElectricCar extends Car {
    public void charge() {
        System.out.println("충전합니다.");
    }
}

```
---

### 🔹 3. 자바의 상속 특징

|항목|설명|
|---|---|
|**단일 상속만 허용**|클래스는 **하나의 부모 클래스만 상속** 가능|
|**다이아몬드 문제 방지**|다중 상속 금지로 메서드 충돌 방지|
|**모든 클래스의 최상위는 `Object`**|명시하지 않아도 `extends Object`가 기본|

---

### 🔹 4. 상속과 메모리 구조
![](https://imgur.com/yxALtcv.png)

- 객체 생성 시 **부모 클래스의 메모리 영역도 함께 생성**
- 메서드 호출 시:  
    1) **자식 클래스에서 먼저 찾고**,  
    2) 없으면 부모 클래스에서 찾는다.  
    3) 끝까지 못 찾으면 컴파일 오류

---

### 🔹 5. 메서드 오버라이딩 (Overriding)

> **상속받은 메서드를 자식 클래스에서 재정의**
```java
@Override
public void move() {
    System.out.println("전기차가 빠르게 이동합니다.");
}

```
#### 📌 오버라이딩 조건

- 이름, 매개변수, 반환 타입 모두 동일해야 함
- 접근 제어자는 **더 넓거나 같아야** 함 (예: `protected` → `public` 가능)
- **static, final, private** 메서드는 오버라이딩 불가
- **생성자**는 오버라이딩할 수 없음

---

### 🔹 6. 오버로딩 vs 오버라이딩

|구분|설명|
|---|---|
|**오버로딩**|같은 이름, 다른 매개변수 → 메서드 중복 정의|
|**오버라이딩**|상속 관계, 같은 시그니처 → 기존 메서드 재정의|

---

### 🔹 7. `protected` 접근 제어자와 상속

- `protected`는 **같은 패키지 or 상속관계에서 접근 가능**
- **다른 패키지**여도 `extends` 관계라면 사용 가능
```java
// 부모 클래스
protected void openDoor() { ... }

// 자식 클래스 (다른 패키지여도 호출 가능)
this.openDoor();

```
---

### 🔹 8. 상속의 장점과 주의점

#### ✅ 장점

- 코드 중복 제거
- 기능 확장 용이 (새로운 자식 타입만 추가하면 됨)
- 유지보수성과 확장성 향상

#### ⚠️ 주의점

- 너무 깊은 상속 구조는 복잡도 ↑
- **"is-a" 관계**가 성립할 때만 상속 사용 (ElectricCar is-a Car)
- 잘못된 상속은 오히려 **결합도 증가** 및 **재사용성 저하**